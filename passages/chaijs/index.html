<!DOCTYPE html>
<html>
  
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="author" content="Finger Dancer">
  
  
  <title>chaijs | Finger Dancer</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="前端,js,单元测试,">
  

  
  <meta name="description" content="chaijs 一个单元测试的函数库">

  

  <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  
    <script src="//unpkg.com/valine/dist/Valine.min.js" async></script>
  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"fytWPWwaraiV8gXYv4GACKRi-gzGzoHsz","appkey":"jGWkDiRKAKSgQkY51HH8WvBh","comment":true,"count":true},
    welcome: {"enable":true,"interval":30},
    start_time: "2019-03-14",
    passwords: ["38c4136589f4b3400f30fa4fd9b9b9dab1efb5ab2852a27551f4b97845462337", ],
    is_post: true,
    lock: false,
    author: "Finger Dancer",
    share: {"twitter":true,"facebook":true,"weibo":true,"qq":true,"wechat":true},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Dancer</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 舞动指尖的不止是钢琴师。。。</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/friends/" target="_self">友链</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/FiggerDancer" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/friends/" target="_self">
            友链
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2019-04-02
    </span>
    
      <span>
        | <a href="/categories/前端/"><i class="fa fa-bookmark"></i>前端</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    chaijs
  </h1>
  
  <article class="passage-article">
    <!-- TOC -->

<li><p><a href="#bdd">BDD</a></p>
<ul>
<li><a href="#语言链">语言链</a></li>
<li><a href="#not">.not</a></li>
<li><a href="#deep">.deep</a></li>
<li><a href="#nested">.nested</a></li>
<li><a href="#own">.own</a></li>
<li><a href="#ordered">.ordered</a></li>
<li><a href="#any">.any</a></li>
<li><a href="#all">.all</a></li>
<li><a href="#atype\msg\">.a(type[,msg])</a></li>
<li><a href="#includeval\msg\">.include(val[,msg])</a></li>
<li><a href="#ok">.ok</a></li>
<li><a href="#true">.true</a></li>
<li><a href="#false">.false</a></li>
<li><a href="#null">.null</a></li>
<li><a href="#undefined">.undefined</a></li>
<li><a href="#nan">.NaN</a></li>
<li><a href="#exist">.exist</a></li>
<li><a href="#empty">.empty</a></li>
<li><a href="#arguments">.arguments</a></li>
<li><a href="#equalval\msg\">.equal(val[,msg])</a></li>
<li><a href="#eqlobj\msg\">.eql(obj[,msg])</a></li>
<li><a href="#aboven\msg\">.above(n[,msg])</a></li>
<li><a href="#leastn\msg\">.least(n[,msg])</a></li>
<li><a href="#belown-msg">.below(n[, msg])</a></li>
<li><a href="#mostn-msg">.most(n[, msg])</a></li>
<li><a href="#withinstart-finish\-msg\">.within(start, finish[, msg])</a></li>
<li><a href="#instanceofconstructor\-msg\">.instanceof(constructor[, msg])</a></li>
<li><a href="#propertyname\-val\-msg\\">.property(name[, val[, msg]])</a></li>
<li>[.ownPropertyDescriptor(name<a href="#ownpropertydescriptorname-descriptor-msg">, descriptor[, msg]])</a></li>
<li><a href="#lengthofn\-msg\">.lengthOf(n[, msg])</a></li>
<li><a href="#matchre\-msg\">.match(re[, msg])</a></li>
<li><a href="#stringstr-msg">.string(str[, msg])</a></li>
<li>[.keys(key1<a href="#keyskey1-key2-">, key2[, …]])</a></li>
<li><a href="#throwerrorlike-errmsgmatcher-msg">.throw([errorLike], [errMsgMatcher], [msg])</a></li>
<li><a href="#respondtomethod-msg">.respondTo(method[, msg])</a></li>
<li><a href="#itself">.itself</a></li>
<li><a href="#satisfymatcher-msg">.satisfy(matcher[, msg])</a></li>
<li><a href="#closetoexpected-delta-msg">.closeTo(expected, delta[, msg])</a></li>
<li><a href="#membersset-msg">.members(set[, msg])</a></li>
<li><a href="#oneoflist-msg">.oneOf(list[, msg])</a></li>
<li>[.change(subject<a href="#changesubject-prop-msg">, prop[, msg]])</a></li>
<li>[.increase(subject<a href="#increasesubject-prop-msg">, prop[, msg]])</a></li>
<li>[.decrease(subject<a href="#decreasesubject-prop-msg">, prop[, msg]])</a></li>
<li><a href="#bydelta-msg">.by(delta[, msg])</a></li>
<li><a href="#extensible">.extensible</a></li>
<li><a href="#sealed">.sealed</a></li>
<li><a href="#frozen">.frozen</a></li>
<li><a href="#finite">.finite</a></li>
<li><a href="#fail\message\">.fail([message])</a></li>
<li><a href="#failactual-expected-\message-\operator\">.fail(actual, expected, [message], [operator])</a></li>
<li><a href="#fail\message\-1">.fail([message])</a></li>
<li><a href="#failactual-expected-\message\-\operator\">.fail(actual, expected, [message], [operator])</a></li>
</ul>
</li>

<!-- /TOC -->
<h1 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h1><blockquote>
<p>BDD 模式使用 except 与 should。它们都使用相同的可链接语言来构造断言，但是它们在最初构造断言的方式上有所不同。</p>
</blockquote>
<h2 id="语言链"><a href="#语言链" class="headerlink" title="语言链"></a>语言链</h2><p>下面的这些语言链可以提高断言的可读性</p>
<p>.to<br>.be<br>.been<br>.is<br>.that<br>.which<br>.and<br>.has<br>.have<br>.with<br>.at<br>.of<br>.same<br>.but<br>.does<br>.still</p>
<h2 id="not"><a href="#not" class="headerlink" title=".not"></a>.not</h2><p>否定链中的所有断言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(function () &#123;&#125;).to.not.throw(); // 该方法不抛错</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.have.property(&apos;b&apos;); // 属性中不包含属性b</span><br><span class="line">expect([1, 2]).to.be.an(&apos;array&apos;).that.does.not.include(3); // 是数组且不包含3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅仅因为您可以用.not 否定任何断言，并不意味着您应该这样做。能力越大，责任越大。通常，最好是断言产生了一个预期的输出，而不是断言没有产生无数个意外输出中的一个。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // 建议</span><br><span class="line">expect(2).to.not.equal(1); // 不建议</span><br></pre></td></tr></table></figure>
<h2 id="deep"><a href="#deep" class="headerlink" title=".deep"></a>.deep</h2><p>使链中的所有.equal、.include、.members、.keys 和.property 断言使用深度相等而不是严格相等(===)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Target object deeply (but not strictly) equals `&#123;a: 1&#125;`</span><br><span class="line">expect(&#123;a: 1&#125;).to.deep.equal(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.equal(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target array deeply (but not strictly) includes `&#123;a: 1&#125;`</span><br><span class="line">expect([&#123;a: 1&#125;]).to.deep.include(&#123;a: 1&#125;);</span><br><span class="line">expect([&#123;a: 1&#125;]).to.not.include(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target object deeply (but not strictly) includes `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.deep.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br><span class="line"></span><br><span class="line">// Target array deeply (but not strictly) has member `&#123;a: 1&#125;`</span><br><span class="line">expect([&#123;a: 1&#125;]).to.have.deep.members([&#123;a: 1&#125;]);</span><br><span class="line">expect([&#123;a: 1&#125;]).to.not.have.members([&#123;a: 1&#125;]);</span><br><span class="line"></span><br><span class="line">// Target set deeply (but not strictly) has key `&#123;a: 1&#125;`</span><br><span class="line">expect(new Set([&#123;a: 1&#125;])).to.have.deep.keys([&#123;a: 1&#125;]);</span><br><span class="line">expect(new Set([&#123;a: 1&#125;])).to.not.have.keys([&#123;a: 1&#125;]);</span><br><span class="line"></span><br><span class="line">// Target object deeply (but not strictly) has property `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.have.deep.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.have.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="nested"><a href="#nested" class="headerlink" title=".nested"></a>.nested</h2><p>在链中跟随的所有.property 和.include 断言中启用点和括号符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.have.nested.property(&apos;a.b[1]&apos;);</span><br><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.nested.include(&#123;&apos;a.b[1]&apos;: &apos;y&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果.或[]是实际属性名称的一部分，可以通过在它们前面添加两个反斜杠来转义它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: &apos;x&apos;&#125;&#125;).to.have.nested.property(&apos;\\.a.\\[b\\]&apos;);</span><br><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: &apos;x&apos;&#125;&#125;).to.nested.include(&#123;&apos;\\.a.\\[b\\]&apos;: &apos;x&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>.nested 不能结合 .own 使用</p>
<h2 id="own"><a href="#own" class="headerlink" title=".own"></a>.own</h2><p>导致链中跟随的所有.property 和.include 断言忽略继承的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.b = 2;</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.have.own.property(&apos;a&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.have.own.property(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.own.include(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.include(&#123;b: 2&#125;).but.not.own.include(&#123;b: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>.own 不可以与 .nested 结合使用</p>
<h2 id="ordered"><a href="#ordered" class="headerlink" title=".ordered"></a>.ordered</h2><p>导致链中跟随的所有.members 断言要求成员具有相同的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2]).to.have.ordered.members([1, 2])</span><br><span class="line">  .but.not.have.ordered.members([2, 1]);</span><br></pre></td></tr></table></figure>
<p>当.include 和.ordered 组合在一起时，顺序从两个数组的开头开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.include.ordered.members([1, 2])</span><br><span class="line">  .but.not.include.ordered.members([2, 3]);</span><br></pre></td></tr></table></figure>
<h2 id="any"><a href="#any" class="headerlink" title=".any"></a>.any</h2><p>导致链中跟随的所有.keys 断言只要求目标具有至少一个给定的键。这与.all 相反，.all 要求目标拥有所有给定的键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2&#125;).to.not.have.any.keys(&apos;c&apos;, &apos;d&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="all"><a href="#all" class="headerlink" title=".all"></a>.all</h2><p>导致链中跟随的所有.keys 断言要求目标具有所有给定的密钥。这与.any 相反，.any 只要求目标具有至少一个给定键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，当在链的前面添加.all 和.any 时，默认情况下使用.all。不过，通常最好还是添加.all，因为它提高了可读性</p>
</blockquote>
<h2 id="a-type-msg"><a href="#a-type-msg" class="headerlink" title=".a(type[,msg])"></a>.a(type[,msg])</h2><ul>
<li>@param { String } type</li>
<li>@param { String } msg <em>option</em><br>断言目标的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.be.a(&apos;string&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.be.an(&apos;object&apos;);</span><br><span class="line">expect(null).to.be.a(&apos;null&apos;);</span><br><span class="line">expect(undefined).to.be.an(&apos;undefined&apos;);</span><br><span class="line">expect(new Error).to.be.an(&apos;error&apos;);</span><br><span class="line">expect(Promise.resolve()).to.be.a(&apos;promise&apos;);</span><br><span class="line">expect(new Float32Array).to.be.a(&apos;float32array&apos;);</span><br><span class="line">expect(Symbol()).to.be.a(&apos;symbol&apos;);</span><br></pre></td></tr></table></figure>
<p>.a 支持通过 Symbol.toStringTag 设置自定义类型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  [Symbol.toStringTag]: &apos;myCustomType&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">expect(myObj).to.be.a(&apos;myCustomType&apos;).but.not.an(&apos;object&apos;);</span><br></pre></td></tr></table></figure>
<p>在对同一个目标进行更多断言之前，最好使用.a 检查目标的类型。这样，您就可以避免任何基于目标类型执行不同操作的断言的意外行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.be.an(&apos;array&apos;).that.includes(2);</span><br><span class="line">expect([]).to.be.an(&apos;array&apos;).that.is.empty;</span><br></pre></td></tr></table></figure>
<p>在链的前面加上 .not。然而，通常最好断言目标是预期的类型，而不是断言它不是许多意外类型之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.be.a(&apos;string&apos;); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.be.an(&apos;array&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.a 接受一个可选的 msg 参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.a(&apos;string&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.a(&apos;string&apos;);</span><br></pre></td></tr></table></figure>
<p>.a 也可以用作语言链，以提高断言的可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;b: 2&#125;).to.have.a.property(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>别名.an 可以与.a 互换使用</p>
<h2 id="include-val-msg"><a href="#include-val-msg" class="headerlink" title=".include(val[,msg])"></a>.include(val[,msg])</h2><ul>
<li>@param { Mixed } val</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>当目标是一个字符串时，.include 断言给定的字符串 val 是目标的子字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.include(&apos;foo&apos;);</span><br></pre></td></tr></table></figure>
<p>当目标是一个数组时，.include 断言给定的 val 是目标的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.include(2);</span><br></pre></td></tr></table></figure>
<p>当目标是一个对象时，.include 断言给定对象 val 的属性是目标属性的子集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.include(&#123;a: 1, b: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>当目标是一个集或弱集时，.include 断言给定的 val 是目标的成员。采用 SameValueZero 等同性算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(new Set([1, 2])).to.include(2);</span><br></pre></td></tr></table></figure>
<p>当目标是映射时，.include 断言给定的 val 是目标的值之一。采用 SameValueZero 等同性算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(new Map([[&apos;a&apos;, 1], [&apos;b&apos;, 2]])).to.include(2);</span><br></pre></td></tr></table></figure>
<p>因为.include 根据目标的类型执行不同的操作，所以在使用.include 之前检查目标的类型非常重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.be.an(&apos;array&apos;).that.includes(2)</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用 strict(===)等式比较数组成员和对象属性。在链的早期添加.deep 来使用 deep 等式(不支持 WeakSet 目标)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Target array deeply (but not strictly) includes `&#123;a: 1&#125;`</span><br><span class="line">expect([&#123;a: 1&#125;]).to.deep.include(&#123;a: 1&#125;);</span><br><span class="line">expect([&#123;a: 1&#125;]).to.not.include(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target object deeply (but not strictly) includes `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.deep.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>默认情况下，在处理对象时搜索目标的所有属性。这包括继承的和/或不可枚举的属性。在链的前面添加.own，以从搜索中排除目标的继承属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.b = 2;</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.own.include(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.include(&#123;b: 2&#125;).but.not.own.include(&#123;b: 2&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，目标对象始终只搜索 val 自己的可枚举属性</p>
</blockquote>
<p>.deep 与 .own 可以结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: 2&#125;&#125;).to.deep.own.include(&#123;a: &#123;b: 2&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.nested，以便在引用嵌套属性时启用点符号和括号符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.nested.include(&#123;&apos;a.b[1]&apos;: &apos;y&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果.或[]是实际属性名称的一部分，可以通过在它们前面添加两个反斜杠来转义它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: 2&#125;&#125;).to.nested.include(&#123;&apos;\\.a.\\[b\\]&apos;: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>.deep 与 .nested 可以结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&#123;c: 3&#125;]&#125;&#125;).to.deep.nested.include(&#123;&apos;a.b[0]&apos;: &#123;c: 3&#125;&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.own 与 .nested 不可以结合使用</p>
</blockquote>
<p>添加 .not 在链接中否定 .include</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.not.include(&apos;taco&apos;);</span><br><span class="line">expect([1, 2, 3]).to.not.include(4);</span><br></pre></td></tr></table></figure>
<p>然而，当目标是对象时，否定.include 是很危险的。问题是，它断言目标对象没有 val 的所有键/值对，但可能有也可能没有，从而产生了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言</p>
<p>当目标对象甚至不期望具有 val 的键时，最好准确地断言它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;c: 3&#125;).to.not.have.any.keys(&apos;a&apos;, &apos;b&apos;); // Recommended</span><br><span class="line">expect(&#123;c: 3&#125;).to.not.include(&#123;a: 1, b: 2&#125;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当预期目标对象具有 val 的键时，通常最好断言每个属性都有其期望值，而不是断言每个属性没有许多未预料到的值之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 3, b: 4&#125;).to.include(&#123;a: 3, b: 4&#125;); // Recommended</span><br><span class="line">expect(&#123;a: 3, b: 4&#125;).to.not.include(&#123;a: 1, b: 2&#125;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.include 接受一个可选的 msg 参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.include(4, &apos;nooo why fail??&apos;);</span><br><span class="line">expect([1, 2, 3], &apos;nooo why fail??&apos;).to.include(4);</span><br></pre></td></tr></table></figure>
<p>.include 也可以用作语言链，导致链中所有.members 和.keys 断言都要求目标是预期集的超集，而不是相同的集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Target object&apos;s keys are a superset of [&apos;a&apos;, &apos;b&apos;] but not identical</span><br><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.include.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.not.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line"></span><br><span class="line">// Target array is a superset of [1, 2] but not identical</span><br><span class="line">expect([1, 2, 3]).to.include.members([1, 2]);</span><br><span class="line">expect([1, 2, 3]).to.not.have.members([1, 2]);</span><br><span class="line"></span><br><span class="line">// Duplicates in the subset are ignored</span><br><span class="line">expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在链的前面添加.any 会导致.keys 断言忽略.include</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Both assertions are identical</span><br><span class="line">expect(&#123;a: 1&#125;).to.include.any.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.any.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>别名.includes,.contain,.contains 可以与.include 互换使用</p>
</blockquote>
<h2 id="ok"><a href="#ok" class="headerlink" title=".ok"></a>.ok</h2><p>断言目标是一个 true 值(在布尔上下文中被认为是 true)。然而，通常最好断言目标是严格地(===)或完全等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(true).to.be.true; // Recommended</span><br><span class="line">expect(true).to.be.ok; // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链上 .ok 前添加 .not 否定 .ok</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expect(0).to.equal(0); // Recommended</span><br><span class="line">expect(0).to.not.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(false).to.be.false; // Recommended</span><br><span class="line">expect(false).to.not.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(null).to.be.null; // Recommended</span><br><span class="line">expect(null).to.not.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(undefined).to.be.undefined; // Recommended</span><br><span class="line">expect(undefined).to.not.be.ok; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(false, &apos;nooo why fail??&apos;).to.be.ok;</span><br></pre></td></tr></table></figure>
<h2 id="true"><a href="#true" class="headerlink" title=".true"></a>.true</h2><p>断言目标严格地(===)等于true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(true).to.be.true;</span><br></pre></td></tr></table></figure>
<p>在.true前添加.not。然而，通常最好断言目标等于它的期望值，而不是不等于true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(false).to.be.false; // Recommended</span><br><span class="line">expect(false).to.not.be.true; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.true; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(false, &apos;nooo why fail??&apos;).to.be.true;</span><br></pre></td></tr></table></figure>
<h2 id="false"><a href="#false" class="headerlink" title=".false"></a>.false</h2><p>断言目标严格地(===)等于false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(false).to.be.false;</span><br></pre></td></tr></table></figure>
<p>在 .false 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(true).to.be.true; // Recommended</span><br><span class="line">expect(true).to.not.be.false; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.false; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(true, &apos;nooo why fail??&apos;).to.be.false;</span><br></pre></td></tr></table></figure>
<h2 id="null"><a href="#null" class="headerlink" title=".null"></a>.null</h2><p>断言目标严格地(===)等于null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(null).to.be.null;</span><br></pre></td></tr></table></figure>
<p>在 .null 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.null; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(42, &apos;nooo why fail??&apos;).to.be.null;</span><br></pre></td></tr></table></figure>
<h2 id="undefined"><a href="#undefined" class="headerlink" title=".undefined"></a>.undefined</h2><p>断言目标严格地(===)等于undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(undefined).to.be.undefined;</span><br></pre></td></tr></table></figure>
<p>在 .undefined 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.undefined; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(42, &apos;nooo why fail??&apos;).to.be.undefined;</span><br></pre></td></tr></table></figure>
<h2 id="NaN"><a href="#NaN" class="headerlink" title=".NaN"></a>.NaN</h2><p>断言目标严格地(===)等于NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(NaN).to.be.NaN;</span><br></pre></td></tr></table></figure>
<p>在 .NaN 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.equal(&apos;foo&apos;); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.be.NaN; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(42, &apos;nooo why fail??&apos;).to.be.NaN;</span><br></pre></td></tr></table></figure>
<h2 id="exist"><a href="#exist" class="headerlink" title=".exist"></a>.exist</h2><p>断言目标严格地(===)不等于null或undefined。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.exist; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(0).to.equal(0); // Recommended</span><br><span class="line">expect(0).to.exist; // Not recommended</span><br></pre></td></tr></table></figure>
<p>在 .exist 前添加 .not</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(null).to.be.null; // Recommended</span><br><span class="line">expect(null).to.not.exist; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(undefined).to.be.undefined; // Recommended</span><br><span class="line">expect(undefined).to.not.exist; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(null, &apos;nooo why fail??&apos;).to.be.exist;</span><br></pre></td></tr></table></figure>
<h2 id="empty"><a href="#empty" class="headerlink" title=".empty"></a>.empty</h2><p>当目标是字符串或数组时，.empty断言目标的length属性严格地(===)等于0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([]).to.be.empty;</span><br><span class="line">expect(&apos;&apos;).to.be.empty;</span><br></pre></td></tr></table></figure>
<p>当目标是映射或集合时，.empty断言目标的size属性严格等于0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(new Set()).to.be.empty;</span><br><span class="line">expect(new Map()).to.be.empty;</span><br></pre></td></tr></table></figure>
<p>当目标是非函数对象时，.empty断言目标没有任何自己的可枚举属性。基于符号键的属性将被排除在计数之外</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&#125;).to.be.empty;</span><br></pre></td></tr></table></figure>
<p>因为.empty根据目标的类型执行不同的操作，所以在使用.empty之前检查目标的类型非常重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([]).to.be.an(&apos;array&apos;).that.is.empty;</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.empty。然而，通常最好是断言目标包含预期值的数量，而不是断言它不是空的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.not.be.empty; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(new Set([1, 2, 3])).to.have.property(&apos;size&apos;, 3); // Recommended</span><br><span class="line">expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(Object.keys(&#123;a: 1&#125;)).to.have.lengthOf(1); // Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.be.empty; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3], &apos;nooo why fail??&apos;).to.be.empty;</span><br></pre></td></tr></table></figure>
<h2 id="arguments"><a href="#arguments" class="headerlink" title=".arguments"></a>.arguments</h2><p>断言目标是arguments对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test () &#123;</span><br><span class="line">  expect(arguments).to.be.arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.arguments。然而，通常最好是断言预期的目标类型，而不是断言它不是arguments对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.be.a(&apos;string&apos;); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.be.arguments; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&#125;, &apos;nooo why fail??&apos;).to.be.arguments;</span><br></pre></td></tr></table></figure>
<p>别名.Arguments可以与.Arguments互换使用</p>
<h2 id="equal-val-msg"><a href="#equal-val-msg" class="headerlink" title=".equal(val[,msg])"></a>.equal(val[,msg])</h2><ul>
<li>@param { Mixed } val</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标严格地(===)等于给定的val</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1);</span><br><span class="line">expect(&apos;foo&apos;).to.equal(&apos;foo&apos;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.deep来使用deep等式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Target object deeply (but not strictly) equals `&#123;a: 1&#125;`</span><br><span class="line">expect(&#123;a: 1&#125;).to.deep.equal(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.equal(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target array deeply (but not strictly) equals `[1, 2]`</span><br><span class="line">expect([1, 2]).to.deep.equal([1, 2]);</span><br><span class="line">expect([1, 2]).to.not.equal([1, 2]);</span><br></pre></td></tr></table></figure>
<p>在链的前面加上。而不是减去。等号。然而，通常最好断言目标等于它的期望值，而不是不等于无数个意外值中的一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.equal(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.equal接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.equal(2);</span><br></pre></td></tr></table></figure>
<p>别名.equals和eq可以与.equal互换使用</p>
<h2 id="eql-obj-msg"><a href="#eql-obj-msg" class="headerlink" title=".eql(obj[,msg])"></a>.eql(obj[,msg])</h2><ul>
<li>@param { Mixed } obj</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标与给定的obj深度相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Target object is deeply (but not strictly) equal to &#123;a: 1&#125;</span><br><span class="line">expect(&#123;a: 1&#125;).to.eql(&#123;a: 1&#125;).but.not.equal(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target array is deeply (but not strictly) equal to [1, 2]</span><br><span class="line">expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.eql。然而，通常最好是断言目标与它的期望值相当，而不是与无数个意想不到的值之一相当</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.eql(&#123;a: 1&#125;); // Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.eql(&#123;b: 2&#125;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.eql接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.eql(&#123;b: 2&#125;, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.eql(&#123;b: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>别名.eqls可以与.eql互换使用</p>
<p>.deep.equal断言几乎与.eql相同，但有一个不同之处:.deep.equal会导致对链中随后的任何其他断言也使用深度相等比较</p>
<h2 id="above-n-msg"><a href="#above-n-msg" class="headerlink" title=".above(n[,msg])"></a>.above(n[,msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或一个日期，分别大于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.be.above(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小大于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.above(2); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来抵消.above</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(1).to.not.be.above(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.above接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.above(2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.above(2);</span><br></pre></td></tr></table></figure>
<p>别名.gt和.greaterThan可以与.above互换使用</p>
<h2 id="least-n-msg"><a href="#least-n-msg" class="headerlink" title=".least(n[,msg])"></a>.least(n[,msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或日期，大于或等于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.be.at.least(1); // Not recommended</span><br><span class="line">expect(2).to.be.at.least(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小大于或等于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.at.least(2); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面加上.not来抵消.least</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.at.least(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.least接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.at.least(2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.at.least(2);</span><br></pre></td></tr></table></figure>
<p>别名.gte可以与.least互换使用</p>
<h2 id="below-n-msg"><a href="#below-n-msg" class="headerlink" title=".below(n[, msg])"></a>.below(n[, msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或一个日期，分别小于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.be.below(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加. lengthof，以断言目标的长度或大小小于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.below(4); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.length(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面加上.not来抵消.below</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.not.be.below(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.下面接受一个可选的msg参数，它是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.be.below(1, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(2, &apos;nooo why fail??&apos;).to.be.below(1);</span><br></pre></td></tr></table></figure>
<p>别名.lt和.lessThan可以与下面的.互换使用</p>
<h2 id="most-n-msg"><a href="#most-n-msg" class="headerlink" title=".most(n[, msg])"></a>.most(n[, msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或日期，分别小于或等于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.be.at.most(2); // Not recommended</span><br><span class="line">expect(1).to.be.at.most(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小小于或等于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.at.most(4); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面加上.not来抵消.most</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.not.be.at.most(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.most大多数情况下接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.be.at.most(1, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(2, &apos;nooo why fail??&apos;).to.be.at.most(1);</span><br></pre></td></tr></table></figure>
<p>别名.lte可以与.most互换使用</p>
<h2 id="within-start-finish-msg"><a href="#within-start-finish-msg" class="headerlink" title=".within(start, finish[, msg])"></a>.within(start, finish[, msg])</h2><ul>
<li>@param { Number } start lower bound inclusive</li>
<li>@param { Number } finish upper bound inclusive</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或日期，大于或等于给定的数字或日期开始，小于或等于给定的数字或日期结束。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.be.within(1, 3); // Not recommended</span><br><span class="line">expect(2).to.be.within(2, 3); // Not recommended</span><br><span class="line">expect(2).to.be.within(1, 2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小大于或等于给定的数字start，小于或等于给定的数字finish</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.within(2, 4); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.within</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.within(2, 4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.within接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(4).to.be.within(1, 3, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(4, &apos;nooo why fail??&apos;).to.be.within(1, 3);</span><br></pre></td></tr></table></figure>
<h2 id="instanceof-constructor-msg"><a href="#instanceof-constructor-msg" class="headerlink" title=".instanceof(constructor[, msg])"></a>.instanceof(constructor[, msg])</h2><ul>
<li>@param { Constructor } constructor</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是给定构造函数的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Cat () &#123; &#125;</span><br><span class="line"></span><br><span class="line">expect(new Cat()).to.be.an.instanceof(Cat);</span><br><span class="line">expect([1, 2]).to.be.an.instanceof(Array);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.instanceof</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.be.an.instanceof(Array);</span><br></pre></td></tr></table></figure>
<p>.instanceof接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.an.instanceof(Array, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.an.instanceof(Array);</span><br></pre></td></tr></table></figure>
<p>由于ES5中的限制，.instanceof在使用Babel或TypeScript之类的换行器时可能并不总是像预期的那样工作。特别是，当子类化内置对象(如Array、Error和Map)时，可能会产生意想不到的结果</p>
<p>别名.instanceOf可以与.instanceOf互换使用</p>
<h2 id="property-name-val-msg"><a href="#property-name-val-msg" class="headerlink" title=".property(name[, val[, msg]])"></a>.property(name[, val[, msg]])</h2><ul>
<li>@param { String } name</li>
<li>@param { Mixed } val (optional)</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标具有具有给定键名的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<p>当提供val时，.property还断言属性的值等于给定的val</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;, 1);</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用strict(===)等式。在链的前面添加.deep来使用deep等式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Target object deeply (but not strictly) has property `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.have.deep.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.have.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br></pre></td></tr></table></figure>
<p>搜索中始终包含目标的可枚举和不可枚举属性。默认情况下，包括own和inherit属性。在链的前面添加.own，以从搜索中排除继承的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.b = 2;</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.have.own.property(&apos;a&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.own.property(&apos;a&apos;, 1);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.have.own.property(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>.deep和.own可以组合在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.have.deep.own.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.nested，以便在引用嵌套属性时启用点符号和括号符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.have.nested.property(&apos;a.b[1]&apos;);</span><br><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.have.nested.property(&apos;a.b[1]&apos;, &apos;y&apos;);</span><br></pre></td></tr></table></figure>
<p>如果.或[]是实际属性名称的一部分，可以通过在它们前面添加两个反斜杠来转义它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: &apos;x&apos;&#125;&#125;).to.have.nested.property(&apos;\\.a.\\[b\\]&apos;);</span><br></pre></td></tr></table></figure>
<p>.deep和.nested 可以结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&#123;c: 3&#125;]&#125;&#125;)</span><br><span class="line">  .to.have.deep.nested.property(&apos;a.b[0]&apos;, &#123;c: 3&#125;);</span><br></pre></td></tr></table></figure>
<p>.own 与 .nested 不可以结合使用</p>
<p>使用 .not 否定 .property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.have.property(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>然而,当提供val否定.property是很危险的。问题是,它创造了不确定性预期通过断言目标没有一个属性与给定的键名,或者它有一个属性与给定键的名字,但它的价值不等于给定的val。它通常是最好的选择来确定的预期的输出,然后写一个断言,只有承认准确输出</p>
<p>当预期目标不具有具有给定键名的属性时，通常最好准确地断言该属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;b: 2&#125;).to.not.have.property(&apos;a&apos;); // Recommended</span><br><span class="line">expect(&#123;b: 2&#125;).to.not.have.property(&apos;a&apos;, 1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当预期目标具有具有给定键名的属性时，通常最好断言该属性具有其期望值，而不是断言它没有许多未预料到的值之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 3&#125;).to.have.property(&apos;a&apos;, 3); // Recommended</span><br><span class="line">expect(&#123;a: 3&#125;).to.not.have.property(&apos;a&apos;, 1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>属性将链中随后的任何断言的目标更改为原始目标对象的属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;).that.is.a(&apos;number&apos;);</span><br></pre></td></tr></table></figure>
<p>属性接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供val时，只使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;, 2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.property(&apos;a&apos;, 2);</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.property(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;b&apos;, undefined, &apos;nooo why fail??&apos;);</span><br></pre></td></tr></table></figure>
<p>上面的断言与不提供val不是一回事，相反，它断言目标对象有一个b属性，它等于undefined。<br>断言.ownProperty和. has ownproperty可以与.own.property互换使用</p>
<h2 id="ownPropertyDescriptor-name-descriptor-msg"><a href="#ownPropertyDescriptor-name-descriptor-msg" class="headerlink" title=".ownPropertyDescriptor(name[, descriptor[, msg]])"></a>.ownPropertyDescriptor(name[, descriptor[, msg]])</h2><ul>
<li>@param { String } name</li>
<li>@param { Object } descriptor <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标具有自己的具有给定键名的属性描述符。搜索中包括可枚举和不可枚举属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<p>当提供描述符时，. ownpropertydescriptor还断言属性的描述符与给定的描述符深度相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 1,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.ownPropertyDescriptor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.have.ownPropertyDescriptor(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>但是，在提供描述符时否定. ownpropertydescriptor是很危险的。问题是，它通过断言目标没有具有给定键名的属性描述符，或者它确实具有具有给定键名的属性描述符，但它并不完全等于给定的描述符，从而产生了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言。<br>当目标不期望具有具有给定键名的属性描述符时，通常最好准确地断言该属性描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;b: 2&#125;).to.not.have.ownPropertyDescriptor(&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;b: 2&#125;).to.not.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 1,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当预期目标具有具有给定键名的属性描述符时，通常最好断言该属性具有其预期的描述符，而不是断言它没有许多未预料到的描述符之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 3&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 3,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;a: 3&#125;).to.not.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 1,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ownpropertydescriptor将链中跟随的任何断言的目标更改为原始目标对象的属性描述符的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;)</span><br><span class="line">  .that.has.property(&apos;enumerable&apos;, true);</span><br></pre></td></tr></table></figure>
<p>ownpropertydescriptor接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供描述符时，只使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 2,</span><br><span class="line">&#125;, &apos;nooo why fail??&apos;);</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 2,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.ownPropertyDescriptor(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;a: 1&#125;)</span><br><span class="line">  .to.have.ownPropertyDescriptor(&apos;b&apos;, undefined, &apos;nooo why fail??&apos;);</span><br></pre></td></tr></table></figure>
<p>上面的断言与不提供描述符不是一回事。相反，它断言目标对象有一个深度等于undefined的b属性描述符。<br>别名.haveOwnPropertyDescriptor可以与.ownPropertyDescriptor互换使用</p>
<h2 id="lengthOf-n-msg"><a href="#lengthOf-n-msg" class="headerlink" title=".lengthOf(n[, msg])"></a>.lengthOf(n[, msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="match-re-msg"><a href="#match-re-msg" class="headerlink" title=".match(re[, msg])"></a>.match(re[, msg])</h2><ul>
<li>@param { RegExp } re</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="string-str-msg"><a href="#string-str-msg" class="headerlink" title=".string(str[, msg])"></a>.string(str[, msg])</h2><ul>
<li>@param { String } str</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="keys-key1-key2-…"><a href="#keys-key1-key2-…" class="headerlink" title=".keys(key1[, key2[, …]])"></a>.keys(key1[, key2[, …]])</h2><ul>
<li>@param { String | Array | Object } keys</li>
</ul>
<h2 id="throw-errorLike-errMsgMatcher-msg"><a href="#throw-errorLike-errMsgMatcher-msg" class="headerlink" title=".throw([errorLike], [errMsgMatcher], [msg])"></a>.throw([errorLike], [errMsgMatcher], [msg])</h2><ul>
<li>@param { Error | ErrorConstructor } errorLike</li>
<li>@param { String | RegExp } errMsgMatcher error message</li>
<li>@param { String } msg <em>optional</em></li>
<li>@see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types" target="_blank" rel="noopener">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types</a></li>
</ul>
<h2 id="respondTo-method-msg"><a href="#respondTo-method-msg" class="headerlink" title=".respondTo(method[, msg])"></a>.respondTo(method[, msg])</h2><ul>
<li>@param { String } method</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="itself"><a href="#itself" class="headerlink" title=".itself"></a>.itself</h2><h2 id="satisfy-matcher-msg"><a href="#satisfy-matcher-msg" class="headerlink" title=".satisfy(matcher[, msg])"></a>.satisfy(matcher[, msg])</h2><ul>
<li>@param { Function } matcher</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="closeTo-expected-delta-msg"><a href="#closeTo-expected-delta-msg" class="headerlink" title=".closeTo(expected, delta[, msg])"></a>.closeTo(expected, delta[, msg])</h2><ul>
<li>@param { Number } expected</li>
<li>@param { Number } delta</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="members-set-msg"><a href="#members-set-msg" class="headerlink" title=".members(set[, msg])"></a>.members(set[, msg])</h2><ul>
<li>@param { Array } set</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="oneOf-list-msg"><a href="#oneOf-list-msg" class="headerlink" title=".oneOf(list[, msg])"></a>.oneOf(list[, msg])</h2><ul>
<li>@param { Array.&lt;*&gt; } list</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="change-subject-prop-msg"><a href="#change-subject-prop-msg" class="headerlink" title=".change(subject[, prop[, msg]])"></a>.change(subject[, prop[, msg]])</h2><ul>
<li>@param { String } subject</li>
<li>@param { String } prop name <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="increase-subject-prop-msg"><a href="#increase-subject-prop-msg" class="headerlink" title=".increase(subject[, prop[, msg]])"></a>.increase(subject[, prop[, msg]])</h2><ul>
<li>@param { String | Function } subject</li>
<li>@param { String } prop name <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="decrease-subject-prop-msg"><a href="#decrease-subject-prop-msg" class="headerlink" title=".decrease(subject[, prop[, msg]])"></a>.decrease(subject[, prop[, msg]])</h2><ul>
<li>@param { String | Function } subject</li>
<li>@param { String } prop name <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="by-delta-msg"><a href="#by-delta-msg" class="headerlink" title=".by(delta[, msg])"></a>.by(delta[, msg])</h2><ul>
<li>@param { Number } delta</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<h2 id="extensible"><a href="#extensible" class="headerlink" title=".extensible"></a>.extensible</h2><h2 id="sealed"><a href="#sealed" class="headerlink" title=".sealed"></a>.sealed</h2><h2 id="frozen"><a href="#frozen" class="headerlink" title=".frozen"></a>.frozen</h2><h2 id="finite"><a href="#finite" class="headerlink" title=".finite"></a>.finite</h2><h2 id="fail-message"><a href="#fail-message" class="headerlink" title=".fail([message])"></a>.fail([message])</h2><h2 id="fail-actual-expected-message-operator"><a href="#fail-actual-expected-message-operator" class="headerlink" title=".fail(actual, expected, [message], [operator])"></a>.fail(actual, expected, [message], [operator])</h2><h2 id="fail-message-1"><a href="#fail-message-1" class="headerlink" title=".fail([message])"></a>.fail([message])</h2><h2 id="fail-actual-expected-message-operator-1"><a href="#fail-actual-expected-message-operator-1" class="headerlink" title=".fail(actual, expected, [message], [operator])"></a>.fail(actual, expected, [message], [operator])</h2><ul>
<li>@param { Mixed } actual</li>
<li>@param { Mixed } expected</li>
<li>@param { String } message</li>
<li>@param { String } operator</li>
</ul>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BDD"><span class="toc-text">BDD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语言链"><span class="toc-text">语言链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not"><span class="toc-text">.not</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deep"><span class="toc-text">.deep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nested"><span class="toc-text">.nested</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#own"><span class="toc-text">.own</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ordered"><span class="toc-text">.ordered</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any"><span class="toc-text">.any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#all"><span class="toc-text">.all</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-type-msg"><span class="toc-text">.a(type[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include-val-msg"><span class="toc-text">.include(val[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ok"><span class="toc-text">.ok</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#true"><span class="toc-text">.true</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#false"><span class="toc-text">.false</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">.null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">.undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NaN"><span class="toc-text">.NaN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exist"><span class="toc-text">.exist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#empty"><span class="toc-text">.empty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments"><span class="toc-text">.arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equal-val-msg"><span class="toc-text">.equal(val[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eql-obj-msg"><span class="toc-text">.eql(obj[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#above-n-msg"><span class="toc-text">.above(n[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#least-n-msg"><span class="toc-text">.least(n[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#below-n-msg"><span class="toc-text">.below(n[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#most-n-msg"><span class="toc-text">.most(n[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#within-start-finish-msg"><span class="toc-text">.within(start, finish[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-constructor-msg"><span class="toc-text">.instanceof(constructor[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property-name-val-msg"><span class="toc-text">.property(name[, val[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ownPropertyDescriptor-name-descriptor-msg"><span class="toc-text">.ownPropertyDescriptor(name[, descriptor[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lengthOf-n-msg"><span class="toc-text">.lengthOf(n[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#match-re-msg"><span class="toc-text">.match(re[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-str-msg"><span class="toc-text">.string(str[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keys-key1-key2-…"><span class="toc-text">.keys(key1[, key2[, …]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw-errorLike-errMsgMatcher-msg"><span class="toc-text">.throw([errorLike], [errMsgMatcher], [msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#respondTo-method-msg"><span class="toc-text">.respondTo(method[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#itself"><span class="toc-text">.itself</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#satisfy-matcher-msg"><span class="toc-text">.satisfy(matcher[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#closeTo-expected-delta-msg"><span class="toc-text">.closeTo(expected, delta[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#members-set-msg"><span class="toc-text">.members(set[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oneOf-list-msg"><span class="toc-text">.oneOf(list[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#change-subject-prop-msg"><span class="toc-text">.change(subject[, prop[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#increase-subject-prop-msg"><span class="toc-text">.increase(subject[, prop[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decrease-subject-prop-msg"><span class="toc-text">.decrease(subject[, prop[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#by-delta-msg"><span class="toc-text">.by(delta[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extensible"><span class="toc-text">.extensible</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sealed"><span class="toc-text">.sealed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frozen"><span class="toc-text">.frozen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finite"><span class="toc-text">.finite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fail-message"><span class="toc-text">.fail([message])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fail-actual-expected-message-operator"><span class="toc-text">.fail(actual, expected, [message], [operator])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fail-message-1"><span class="toc-text">.fail([message])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fail-actual-expected-message-operator-1"><span class="toc-text">.fail(actual, expected, [message], [operator])</span></a></li></ol></li></ol>
  </div>
</aside>
  
    <aside class="passage-copyright">
      <div>本文作者: Finger Dancer</div>
      
        <div>
          原文链接: 
          <a href target="_blank">https://figgerdancer.github.io/passages/chaijs/</a>
        </div>
      
      <div>
        版权声明: 本博客所有文章除特别声明外, 均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议. 转载请注明出处!
      </div>
    </aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/js/"><i class="fa fa-tags"></i>js</a>
     
      <a href="/tags/单元测试/"><i class="fa fa-tags"></i>单元测试</a>
    
    </div>
  
</div>

    </main>
    
      
<div class="site-comment-contanier" data-plateform="leancloud">
  
    <p id="site-comment-info">
      <i class="fa fa-spinner fa-spin"></i> 评论加载中
    </p>
    <div id="site-comment"></div>
  
</div>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">博客推荐</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/" target="_blank">GodBMW</a>
          </span>
        
          <span class="site-footer-item">
            <a href="http://ruanyifeng.com/" target="_blank">阮一峰的个人网站</a>
          </span>
        
      </div>
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">系列教程</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/categories/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/" target="_blank">webpack4系列教程</a>
          </span>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/design-patterns/" target="_blank">设计模式手册</a>
          </span>
        
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
      <div class="site-footer-info">
        <i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客
      </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: ysulixiangyuan@gmail.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
        
          <div>
            <img src="/images/wechat.png" alt="WeChat">
            
              <p>WeChat</p>
            
          </div>
        
          <div>
            <img src="/images/alipay.png" alt="AliPay">
            
              <p>AliPay</p>
            
          </div>
        
      </div>
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/passages/CSS-GRADIENT/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/passages/Swiper/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
      <a href="#site-comment" data-enable="true">
        <i class="fa fa-commenting"></i>
      </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    <a href="javascript:void(0);" id="site-reward">
      <i class="fa fa-thumbs-up"></i>
    </a>
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
    <a id="share-btn-twitter" href="javascript:void(0);" target="_blank">
      <i class="fa fa-twitter"></i>
    </a>
  
  
    <a id="share-btn-facebook" href="javascript:void(0);" target="_blank">
      <i class="fa fa-facebook"></i>
    </a>
  
  
    <a id="share-btn-weibo" href="javascript:void(0);" target="_blank">
      <i class="fa fa-weibo"></i>
    </a>
  
  
    <a id="share-btn-qq" href="javascript:void(0);" target="_blank">
      <i class="fa fa-qq"></i>
    </a>
  
  
    <a id="share-btn-wechat" href="javascript:void(0);" target="_blank">
      <i class="fa fa-wechat"></i>
    </a>
  
</div>
    





    
  </body>
</html>