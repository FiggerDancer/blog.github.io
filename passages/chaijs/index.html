<!DOCTYPE html>
<html>
  
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  <meta name="author" content="Finger Dancer">
  
  
  <title>chaijs | Finger Dancer</title>

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
    <meta name="keywords" content="前端,js,单元测试,">
  

  
  <meta name="description" content="chaijs 一个单元测试的函数库">

  

  <script src="//cdn.jsdelivr.net/npm/leancloud-storage@3.11.1/dist/av-min.js" async></script>

  
    <script type="text/javascript" src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML" async></script>
  

  
    <script src="//unpkg.com/valine/dist/Valine.min.js" async></script>
  

  

  <script>
  // theme-ad's config script
  // it can be used in every script
  
  window.AD_CONFIG = {
    leancloud: {"appid":"fytWPWwaraiV8gXYv4GACKRi-gzGzoHsz","appkey":"jGWkDiRKAKSgQkY51HH8WvBh","comment":true,"count":true},
    welcome: {"enable":true,"interval":30},
    start_time: "2019-03-14",
    passwords: ["38c4136589f4b3400f30fa4fd9b9b9dab1efb5ab2852a27551f4b97845462337", ],
    is_post: true,
    lock: false,
    author: "Finger Dancer",
    share: {"twitter":true,"facebook":true,"weibo":true,"qq":true,"wechat":true},
    mathjax: true,
    page_type: "",
    root: "/"
  };
</script>

  <script src="/vendor/sha256.min.js"></script>
<script src="/js/auth.js"></script>
<script src="/js/index.js"></script>
<script src="/vendor/qrcode.min.js"></script>

  
    <link rel="icon" href="/images/favicon.ico">
    <link rel="apple-touch-icon" href="/images/touch-icon.png">
  

  <link href="//netdna.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">

  <link rel="stylesheet" href="/css/index.css">
<link rel="stylesheet" href="/styles/components/highlight/highlight.css">

  
</head>
  <body>
    <header class="site-header">
  <div class="site-header-brand">
    
      <span class="site-header-brand-title">
        <a href="/">Dancer</a>
      </span>
    
    
      <span class="site-header-brand-motto"> | 舞动指尖的不止是钢琴师。。。</span>
    
  </div>
  <div class="site-header-right">
    <nav class="site-header-navigation">
      
        <a href="/" target="_self">首页</a>
      
        <a href="/archives/" target="_self">归档</a>
      
        <a href="/tags/" target="_self">标签</a>
      
        <a href="/categories/" target="_self">分类</a>
      
        <a href="/friends/" target="_self">友链</a>
      
        <a href="/about/" target="_self">关于</a>
      
    </nav>
    <div class="site-header-btn">
      
        <a href="https://github.com/FiggerDancer" target="_blank" id="site-github">
          <i class="fa fa-github-alt"></i>
        </a>
      
      <a href="javascript:void(0);" id="site-search">
        <i class="fa fa-search"></i>
      </a>
      <a href="javascript:void(0);" id="site-nav-btn">
        <i class="fa fa-ellipsis-v"></i>
      </a>
    </div>
  </div>
</header>
<nav class="table-content" id="site-nav">
  <div class="table-content-title">
    <span>导航</span>
  </div>
  <div class="table-content-main">
    <ol class="toc">
      
        <li class="toc-item">
          <a href="/" target="_self">
            首页
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/archives/" target="_self">
            归档
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/tags/" target="_self">
            标签
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/categories/" target="_self">
            分类
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/friends/" target="_self">
            友链
          </a>
        </li>
      
        <li class="toc-item">
          <a href="/about/" target="_self">
            关于
          </a>
        </li>
      
    </ol>
  </div>
</nav>
<div id="site-process"></div>
    <main>
      
  <div class="passage">
  <div class="passage-meta">
    <span>
      <i class="fa fa-calendar"></i>2019-04-02
    </span>
    
      <span>
        | <a href="/categories/前端/"><i class="fa fa-bookmark"></i>前端</a>
      </span>
    
    
      <span>
        | <i class="fa fa-unlock-alt"></i>UNLOCK
      </span>
    
  </div>
  <h1 class="passage-title">
    chaijs
  </h1>
  
  <article class="passage-article">
    <!-- TOC -->

<li><p><a href="#bdd">BDD</a></p>
<ul>
<li><a href="#语言链">语言链</a></li>
<li><a href="#not">.not</a></li>
<li><a href="#deep">.deep</a></li>
<li><a href="#nested">.nested</a></li>
<li><a href="#own">.own</a></li>
<li><a href="#ordered">.ordered</a></li>
<li><a href="#any">.any</a></li>
<li><a href="#all">.all</a></li>
<li><a href="#atypemsg">.a(type[,msg])</a></li>
<li><a href="#includevalmsg">.include(val[,msg])</a></li>
<li><a href="#ok">.ok</a></li>
<li><a href="#true">.true</a></li>
<li><a href="#false">.false</a></li>
<li><a href="#null">.null</a></li>
<li><a href="#undefined">.undefined</a></li>
<li><a href="#nan">.NaN</a></li>
<li><a href="#exist">.exist</a></li>
<li><a href="#empty">.empty</a></li>
<li><a href="#arguments">.arguments</a></li>
<li><a href="#equalvalmsg">.equal(val[,msg])</a></li>
<li><a href="#eqlobjmsg">.eql(obj[,msg])</a></li>
<li><a href="#abovenmsg">.above(n[,msg])</a></li>
<li><a href="#leastnmsg">.least(n[,msg])</a></li>
<li><a href="#belown-msg">.below(n[, msg])</a></li>
<li><a href="#mostn-msg">.most(n[, msg])</a></li>
<li><a href="#withinstart-finish-msg">.within(start, finish[, msg])</a></li>
<li><a href="#instanceofconstructor-msg">.instanceof(constructor[, msg])</a></li>
<li>[.property(name<a href="#propertyname-val-msg">, val[, msg]])</a></li>
<li>[.ownPropertyDescriptor(name<a href="#ownpropertydescriptorname-descriptor-msg">, descriptor[, msg]])</a></li>
<li><a href="#lengthofn-msg">.lengthOf(n[, msg])</a></li>
<li><a href="#matchre-msg">.match(re[, msg])</a></li>
<li><a href="#stringstr-msg">.string(str[, msg])</a></li>
<li>[.keys(key1<a href="#keyskey1-key2-">, key2[, …]])</a></li>
<li><a href="#throwerrorlike-errmsgmatcher-msg">.throw([errorLike], [errMsgMatcher], [msg])</a></li>
<li><a href="#respondtomethod-msg">.respondTo(method[, msg])</a></li>
<li><a href="#itself">.itself</a></li>
<li><a href="#satisfymatcher-msg">.satisfy(matcher[, msg])</a></li>
<li><a href="#closetoexpected-delta-msg">.closeTo(expected, delta[, msg])</a></li>
<li><a href="#membersset-msg">.members(set[, msg])</a></li>
<li><a href="#oneoflist-msg">.oneOf(list[, msg])</a></li>
<li>[.change(subject<a href="#changesubject-prop-msg">, prop[, msg]])</a></li>
<li>[.increase(subject<a href="#increasesubject-prop-msg">, prop[, msg]])</a></li>
<li>[.decrease(subject<a href="#decreasesubject-prop-msg">, prop[, msg]])</a></li>
<li><a href="#bydelta-msg">.by(delta[, msg])</a></li>
<li><a href="#extensible">.extensible</a></li>
<li><a href="#sealed">.sealed</a></li>
<li><a href="#frozen">.frozen</a></li>
<li><a href="#finite">.finite</a></li>
<li><a href="#failmessage">.fail([message])</a></li>
<li><a href="#failactual-expected-message-operator">.fail(actual, expected, [message], [operator])</a></li>
</ul>
</li>

<!-- /TOC -->
<h1 id="BDD"><a href="#BDD" class="headerlink" title="BDD"></a>BDD</h1><blockquote>
<p>BDD 模式使用 except 与 should。它们都使用相同的可链接语言来构造断言，但是它们在最初构造断言的方式上有所不同。</p>
</blockquote>
<h2 id="语言链"><a href="#语言链" class="headerlink" title="语言链"></a>语言链</h2><p>下面的这些语言链可以提高断言的可读性</p>
<p>.to<br>.be<br>.been<br>.is<br>.that<br>.which<br>.and<br>.has<br>.have<br>.with<br>.at<br>.of<br>.same<br>.but<br>.does<br>.still</p>
<h2 id="not"><a href="#not" class="headerlink" title=".not"></a>.not</h2><p>否定链中的所有断言。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(function () &#123;&#125;).to.not.throw(); // 该方法不抛错</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.have.property(&apos;b&apos;); // 属性中不包含属性b</span><br><span class="line">expect([1, 2]).to.be.an(&apos;array&apos;).that.does.not.include(3); // 是数组且不包含3</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仅仅因为您可以用.not 否定任何断言，并不意味着您应该这样做。能力越大，责任越大。通常，最好是断言产生了一个预期的输出，而不是断言没有产生无数个意外输出中的一个。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // 建议</span><br><span class="line">expect(2).to.not.equal(1); // 不建议</span><br></pre></td></tr></table></figure>
<h2 id="deep"><a href="#deep" class="headerlink" title=".deep"></a>.deep</h2><p>使链中的所有.equal、.include、.members、.keys 和.property 断言使用深度相等而不是严格相等(===)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// Target object deeply (but not strictly) equals `&#123;a: 1&#125;`</span><br><span class="line">expect(&#123;a: 1&#125;).to.deep.equal(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.equal(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target array deeply (but not strictly) includes `&#123;a: 1&#125;`</span><br><span class="line">expect([&#123;a: 1&#125;]).to.deep.include(&#123;a: 1&#125;);</span><br><span class="line">expect([&#123;a: 1&#125;]).to.not.include(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target object deeply (but not strictly) includes `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.deep.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br><span class="line"></span><br><span class="line">// Target array deeply (but not strictly) has member `&#123;a: 1&#125;`</span><br><span class="line">expect([&#123;a: 1&#125;]).to.have.deep.members([&#123;a: 1&#125;]);</span><br><span class="line">expect([&#123;a: 1&#125;]).to.not.have.members([&#123;a: 1&#125;]);</span><br><span class="line"></span><br><span class="line">// Target set deeply (but not strictly) has key `&#123;a: 1&#125;`</span><br><span class="line">expect(new Set([&#123;a: 1&#125;])).to.have.deep.keys([&#123;a: 1&#125;]);</span><br><span class="line">expect(new Set([&#123;a: 1&#125;])).to.not.have.keys([&#123;a: 1&#125;]);</span><br><span class="line"></span><br><span class="line">// Target object deeply (but not strictly) has property `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.have.deep.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.have.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="nested"><a href="#nested" class="headerlink" title=".nested"></a>.nested</h2><p>在链中跟随的所有.property 和.include 断言中启用点和括号符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.have.nested.property(&apos;a.b[1]&apos;);</span><br><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.nested.include(&#123;&apos;a.b[1]&apos;: &apos;y&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果.或[]是实际属性名称的一部分，可以通过在它们前面添加两个反斜杠来转义它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: &apos;x&apos;&#125;&#125;).to.have.nested.property(&apos;\\.a.\\[b\\]&apos;);</span><br><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: &apos;x&apos;&#125;&#125;).to.nested.include(&#123;&apos;\\.a.\\[b\\]&apos;: &apos;x&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>.nested 不能结合 .own 使用</p>
<h2 id="own"><a href="#own" class="headerlink" title=".own"></a>.own</h2><p>导致链中跟随的所有.property 和.include 断言忽略继承的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.b = 2;</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.have.own.property(&apos;a&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.have.own.property(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.own.include(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.include(&#123;b: 2&#125;).but.not.own.include(&#123;b: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>.own 不可以与 .nested 结合使用</p>
<h2 id="ordered"><a href="#ordered" class="headerlink" title=".ordered"></a>.ordered</h2><p>导致链中跟随的所有.members 断言要求成员具有相同的顺序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2]).to.have.ordered.members([1, 2])</span><br><span class="line">  .but.not.have.ordered.members([2, 1]);</span><br></pre></td></tr></table></figure>
<p>当.include 和.ordered 组合在一起时，顺序从两个数组的开头开始</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.include.ordered.members([1, 2])</span><br><span class="line">  .but.not.include.ordered.members([2, 3]);</span><br></pre></td></tr></table></figure>
<h2 id="any"><a href="#any" class="headerlink" title=".any"></a>.any</h2><p>导致链中跟随的所有.keys 断言只要求目标具有至少一个给定的键。这与.all 相反，.all 要求目标拥有所有给定的键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2&#125;).to.not.have.any.keys(&apos;c&apos;, &apos;d&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="all"><a href="#all" class="headerlink" title=".all"></a>.all</h2><p>导致链中跟随的所有.keys 断言要求目标具有所有给定的密钥。这与.any 相反，.any 只要求目标具有至少一个给定键</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，当在链的前面添加.all 和.any 时，默认情况下使用.all。不过，通常最好还是添加.all，因为它提高了可读性</p>
</blockquote>
<h2 id="a-type-msg"><a href="#a-type-msg" class="headerlink" title=".a(type[,msg])"></a>.a(type[,msg])</h2><ul>
<li>@param { String } type</li>
<li>@param { String } msg <em>option</em><br>断言目标的类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.be.a(&apos;string&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.be.an(&apos;object&apos;);</span><br><span class="line">expect(null).to.be.a(&apos;null&apos;);</span><br><span class="line">expect(undefined).to.be.an(&apos;undefined&apos;);</span><br><span class="line">expect(new Error).to.be.an(&apos;error&apos;);</span><br><span class="line">expect(Promise.resolve()).to.be.a(&apos;promise&apos;);</span><br><span class="line">expect(new Float32Array).to.be.a(&apos;float32array&apos;);</span><br><span class="line">expect(Symbol()).to.be.a(&apos;symbol&apos;);</span><br></pre></td></tr></table></figure>
<p>.a 支持通过 Symbol.toStringTag 设置自定义类型的对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;</span><br><span class="line">  [Symbol.toStringTag]: &apos;myCustomType&apos;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">expect(myObj).to.be.a(&apos;myCustomType&apos;).but.not.an(&apos;object&apos;);</span><br></pre></td></tr></table></figure>
<p>在对同一个目标进行更多断言之前，最好使用.a 检查目标的类型。这样，您就可以避免任何基于目标类型执行不同操作的断言的意外行为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.be.an(&apos;array&apos;).that.includes(2);</span><br><span class="line">expect([]).to.be.an(&apos;array&apos;).that.is.empty;</span><br></pre></td></tr></table></figure>
<p>在链的前面加上 .not。然而，通常最好断言目标是预期的类型，而不是断言它不是许多意外类型之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.be.a(&apos;string&apos;); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.be.an(&apos;array&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.a 接受一个可选的 msg 参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.a(&apos;string&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.a(&apos;string&apos;);</span><br></pre></td></tr></table></figure>
<p>.a 也可以用作语言链，以提高断言的可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;b: 2&#125;).to.have.a.property(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>别名.an 可以与.a 互换使用</p>
<h2 id="include-val-msg"><a href="#include-val-msg" class="headerlink" title=".include(val[,msg])"></a>.include(val[,msg])</h2><ul>
<li>@param { Mixed } val</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>当目标是一个字符串时，.include 断言给定的字符串 val 是目标的子字符串</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.include(&apos;foo&apos;);</span><br></pre></td></tr></table></figure>
<p>当目标是一个数组时，.include 断言给定的 val 是目标的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.include(2);</span><br></pre></td></tr></table></figure>
<p>当目标是一个对象时，.include 断言给定对象 val 的属性是目标属性的子集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.include(&#123;a: 1, b: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>当目标是一个集或弱集时，.include 断言给定的 val 是目标的成员。采用 SameValueZero 等同性算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(new Set([1, 2])).to.include(2);</span><br></pre></td></tr></table></figure>
<p>当目标是映射时，.include 断言给定的 val 是目标的值之一。采用 SameValueZero 等同性算法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(new Map([[&apos;a&apos;, 1], [&apos;b&apos;, 2]])).to.include(2);</span><br></pre></td></tr></table></figure>
<p>因为.include 根据目标的类型执行不同的操作，所以在使用.include 之前检查目标的类型非常重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.be.an(&apos;array&apos;).that.includes(2)</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用 strict(===)等式比较数组成员和对象属性。在链的早期添加.deep 来使用 deep 等式(不支持 WeakSet 目标)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Target array deeply (but not strictly) includes `&#123;a: 1&#125;`</span><br><span class="line">expect([&#123;a: 1&#125;]).to.deep.include(&#123;a: 1&#125;);</span><br><span class="line">expect([&#123;a: 1&#125;]).to.not.include(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target object deeply (but not strictly) includes `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.deep.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.include(&#123;x: &#123;a: 1&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>默认情况下，在处理对象时搜索目标的所有属性。这包括继承的和/或不可枚举的属性。在链的前面添加.own，以从搜索中排除目标的继承属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.b = 2;</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.own.include(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.include(&#123;b: 2&#125;).but.not.own.include(&#123;b: 2&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，目标对象始终只搜索 val 自己的可枚举属性</p>
</blockquote>
<p>.deep 与 .own 可以结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: 2&#125;&#125;).to.deep.own.include(&#123;a: &#123;b: 2&#125;&#125;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.nested，以便在引用嵌套属性时启用点符号和括号符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.nested.include(&#123;&apos;a.b[1]&apos;: &apos;y&apos;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果.或[]是实际属性名称的一部分，可以通过在它们前面添加两个反斜杠来转义它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: 2&#125;&#125;).to.nested.include(&#123;&apos;\\.a.\\[b\\]&apos;: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>.deep 与 .nested 可以结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&#123;c: 3&#125;]&#125;&#125;).to.deep.nested.include(&#123;&apos;a.b[0]&apos;: &#123;c: 3&#125;&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>.own 与 .nested 不可以结合使用</p>
</blockquote>
<p>添加 .not 在链接中否定 .include</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.not.include(&apos;taco&apos;);</span><br><span class="line">expect([1, 2, 3]).to.not.include(4);</span><br></pre></td></tr></table></figure>
<p>然而，当目标是对象时，否定.include 是很危险的。问题是，它断言目标对象没有 val 的所有键/值对，但可能有也可能没有，从而产生了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言</p>
<p>当目标对象甚至不期望具有 val 的键时，最好准确地断言它</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;c: 3&#125;).to.not.have.any.keys(&apos;a&apos;, &apos;b&apos;); // Recommended</span><br><span class="line">expect(&#123;c: 3&#125;).to.not.include(&#123;a: 1, b: 2&#125;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当预期目标对象具有 val 的键时，通常最好断言每个属性都有其期望值，而不是断言每个属性没有许多未预料到的值之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 3, b: 4&#125;).to.include(&#123;a: 3, b: 4&#125;); // Recommended</span><br><span class="line">expect(&#123;a: 3, b: 4&#125;).to.not.include(&#123;a: 1, b: 2&#125;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.include 接受一个可选的 msg 参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.include(4, &apos;nooo why fail??&apos;);</span><br><span class="line">expect([1, 2, 3], &apos;nooo why fail??&apos;).to.include(4);</span><br></pre></td></tr></table></figure>
<p>.include 也可以用作语言链，导致链中所有.members 和.keys 断言都要求目标是预期集的超集，而不是相同的集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Target object&apos;s keys are a superset of [&apos;a&apos;, &apos;b&apos;] but not identical</span><br><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.include.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.not.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line"></span><br><span class="line">// Target array is a superset of [1, 2] but not identical</span><br><span class="line">expect([1, 2, 3]).to.include.members([1, 2]);</span><br><span class="line">expect([1, 2, 3]).to.not.have.members([1, 2]);</span><br><span class="line"></span><br><span class="line">// Duplicates in the subset are ignored</span><br><span class="line">expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意，在链的前面添加.any 会导致.keys 断言忽略.include</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Both assertions are identical</span><br><span class="line">expect(&#123;a: 1&#125;).to.include.any.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.any.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>别名.includes,.contain,.contains 可以与.include 互换使用</p>
</blockquote>
<h2 id="ok"><a href="#ok" class="headerlink" title=".ok"></a>.ok</h2><p>断言目标是一个 true 值(在布尔上下文中被认为是 true)。然而，通常最好断言目标是严格地(===)或完全等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(true).to.be.true; // Recommended</span><br><span class="line">expect(true).to.be.ok; // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链上 .ok 前添加 .not 否定 .ok</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">expect(0).to.equal(0); // Recommended</span><br><span class="line">expect(0).to.not.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(false).to.be.false; // Recommended</span><br><span class="line">expect(false).to.not.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(null).to.be.null; // Recommended</span><br><span class="line">expect(null).to.not.be.ok; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(undefined).to.be.undefined; // Recommended</span><br><span class="line">expect(undefined).to.not.be.ok; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(false, &apos;nooo why fail??&apos;).to.be.ok;</span><br></pre></td></tr></table></figure>
<h2 id="true"><a href="#true" class="headerlink" title=".true"></a>.true</h2><p>断言目标严格地(===)等于true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(true).to.be.true;</span><br></pre></td></tr></table></figure>
<p>在.true前添加.not。然而，通常最好断言目标等于它的期望值，而不是不等于true</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(false).to.be.false; // Recommended</span><br><span class="line">expect(false).to.not.be.true; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.true; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(false, &apos;nooo why fail??&apos;).to.be.true;</span><br></pre></td></tr></table></figure>
<h2 id="false"><a href="#false" class="headerlink" title=".false"></a>.false</h2><p>断言目标严格地(===)等于false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(false).to.be.false;</span><br></pre></td></tr></table></figure>
<p>在 .false 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 false</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(true).to.be.true; // Recommended</span><br><span class="line">expect(true).to.not.be.false; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.false; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(true, &apos;nooo why fail??&apos;).to.be.false;</span><br></pre></td></tr></table></figure>
<h2 id="null"><a href="#null" class="headerlink" title=".null"></a>.null</h2><p>断言目标严格地(===)等于null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(null).to.be.null;</span><br></pre></td></tr></table></figure>
<p>在 .null 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 null</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.null; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(42, &apos;nooo why fail??&apos;).to.be.null;</span><br></pre></td></tr></table></figure>
<h2 id="undefined"><a href="#undefined" class="headerlink" title=".undefined"></a>.undefined</h2><p>断言目标严格地(===)等于undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(undefined).to.be.undefined;</span><br></pre></td></tr></table></figure>
<p>在 .undefined 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 undefined</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.undefined; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(42, &apos;nooo why fail??&apos;).to.be.undefined;</span><br></pre></td></tr></table></figure>
<h2 id="NaN"><a href="#NaN" class="headerlink" title=".NaN"></a>.NaN</h2><p>断言目标严格地(===)等于NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(NaN).to.be.NaN;</span><br></pre></td></tr></table></figure>
<p>在 .NaN 前添加 .not 。然而，通常最好断言目标等于它的期望值，而不是不等于 NaN</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.equal(&apos;foo&apos;); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.be.NaN; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(42, &apos;nooo why fail??&apos;).to.be.NaN;</span><br></pre></td></tr></table></figure>
<h2 id="exist"><a href="#exist" class="headerlink" title=".exist"></a>.exist</h2><p>断言目标严格地(===)不等于null或undefined。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.exist; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(0).to.equal(0); // Recommended</span><br><span class="line">expect(0).to.exist; // Not recommended</span><br></pre></td></tr></table></figure>
<p>在 .exist 前添加 .not</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(null).to.be.null; // Recommended</span><br><span class="line">expect(null).to.not.exist; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(undefined).to.be.undefined; // Recommended</span><br><span class="line">expect(undefined).to.not.exist; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(null, &apos;nooo why fail??&apos;).to.be.exist;</span><br></pre></td></tr></table></figure>
<h2 id="empty"><a href="#empty" class="headerlink" title=".empty"></a>.empty</h2><p>当目标是字符串或数组时，.empty断言目标的length属性严格地(===)等于0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([]).to.be.empty;</span><br><span class="line">expect(&apos;&apos;).to.be.empty;</span><br></pre></td></tr></table></figure>
<p>当目标是映射或集合时，.empty断言目标的size属性严格等于0</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(new Set()).to.be.empty;</span><br><span class="line">expect(new Map()).to.be.empty;</span><br></pre></td></tr></table></figure>
<p>当目标是非函数对象时，.empty断言目标没有任何自己的可枚举属性。基于符号键的属性将被排除在计数之外</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&#125;).to.be.empty;</span><br></pre></td></tr></table></figure>
<p>因为.empty根据目标的类型执行不同的操作，所以在使用.empty之前检查目标的类型非常重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([]).to.be.an(&apos;array&apos;).that.is.empty;</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.empty。然而，通常最好是断言目标包含预期值的数量，而不是断言它不是空的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.not.be.empty; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(new Set([1, 2, 3])).to.have.property(&apos;size&apos;, 3); // Recommended</span><br><span class="line">expect(new Set([1, 2, 3])).to.not.be.empty; // Not recommended</span><br><span class="line"></span><br><span class="line">expect(Object.keys(&#123;a: 1&#125;)).to.have.lengthOf(1); // Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.be.empty; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3], &apos;nooo why fail??&apos;).to.be.empty;</span><br></pre></td></tr></table></figure>
<h2 id="arguments"><a href="#arguments" class="headerlink" title=".arguments"></a>.arguments</h2><p>断言目标是arguments对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function test () &#123;</span><br><span class="line">  expect(arguments).to.be.arguments;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test();</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.arguments。然而，通常最好是断言预期的目标类型，而不是断言它不是arguments对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.be.a(&apos;string&apos;); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.be.arguments; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&#125;, &apos;nooo why fail??&apos;).to.be.arguments;</span><br></pre></td></tr></table></figure>
<p>别名.Arguments可以与.Arguments互换使用</p>
<h2 id="equal-val-msg"><a href="#equal-val-msg" class="headerlink" title=".equal(val[,msg])"></a>.equal(val[,msg])</h2><ul>
<li>@param { Mixed } val</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标严格地(===)等于给定的val</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1);</span><br><span class="line">expect(&apos;foo&apos;).to.equal(&apos;foo&apos;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.deep来使用deep等式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Target object deeply (but not strictly) equals `&#123;a: 1&#125;`</span><br><span class="line">expect(&#123;a: 1&#125;).to.deep.equal(&#123;a: 1&#125;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.equal(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target array deeply (but not strictly) equals `[1, 2]`</span><br><span class="line">expect([1, 2]).to.deep.equal([1, 2]);</span><br><span class="line">expect([1, 2]).to.not.equal([1, 2]);</span><br></pre></td></tr></table></figure>
<p>在链的前面加上。而不是减去。等号。然而，通常最好断言目标等于它的期望值，而不是不等于无数个意外值中的一个</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.equal(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.equal接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.equal(2);</span><br></pre></td></tr></table></figure>
<p>别名.equals和eq可以与.equal互换使用</p>
<h2 id="eql-obj-msg"><a href="#eql-obj-msg" class="headerlink" title=".eql(obj[,msg])"></a>.eql(obj[,msg])</h2><ul>
<li>@param { Mixed } obj</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标与给定的obj深度相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Target object is deeply (but not strictly) equal to &#123;a: 1&#125;</span><br><span class="line">expect(&#123;a: 1&#125;).to.eql(&#123;a: 1&#125;).but.not.equal(&#123;a: 1&#125;);</span><br><span class="line"></span><br><span class="line">// Target array is deeply (but not strictly) equal to [1, 2]</span><br><span class="line">expect([1, 2]).to.eql([1, 2]).but.not.equal([1, 2]);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.eql。然而，通常最好是断言目标与它的期望值相当，而不是与无数个意想不到的值之一相当</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.eql(&#123;a: 1&#125;); // Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.eql(&#123;b: 2&#125;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.eql接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.eql(&#123;b: 2&#125;, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.eql(&#123;b: 2&#125;);</span><br></pre></td></tr></table></figure>
<p>别名.eqls可以与.eql互换使用</p>
<p>.deep.equal断言几乎与.eql相同，但有一个不同之处:.deep.equal会导致对链中随后的任何其他断言也使用深度相等比较</p>
<h2 id="above-n-msg"><a href="#above-n-msg" class="headerlink" title=".above(n[,msg])"></a>.above(n[,msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或一个日期，分别大于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.be.above(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小大于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.above(2); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.above(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来抵消.above</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(1).to.not.be.above(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.above接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.above(2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.above(2);</span><br></pre></td></tr></table></figure>
<p>别名.gt和.greaterThan可以与.above互换使用</p>
<h2 id="least-n-msg"><a href="#least-n-msg" class="headerlink" title=".least(n[,msg])"></a>.least(n[,msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或日期，大于或等于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.be.at.least(1); // Not recommended</span><br><span class="line">expect(2).to.be.at.least(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小大于或等于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.at.least(2); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.at.least(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面加上.not来抵消.least</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.at.least(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.least接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.at.least(2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.at.least(2);</span><br></pre></td></tr></table></figure>
<p>别名.gte可以与.least互换使用</p>
<h2 id="below-n-msg"><a href="#below-n-msg" class="headerlink" title=".below(n[, msg])"></a>.below(n[, msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或一个日期，分别小于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.be.below(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加. lengthof，以断言目标的长度或大小小于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.below(4); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.length(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.below(4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面加上.not来抵消.below</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.not.be.below(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.下面接受一个可选的msg参数，它是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.be.below(1, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(2, &apos;nooo why fail??&apos;).to.be.below(1);</span><br></pre></td></tr></table></figure>
<p>别名.lt和.lessThan可以与下面的.互换使用</p>
<h2 id="most-n-msg"><a href="#most-n-msg" class="headerlink" title=".most(n[, msg])"></a>.most(n[, msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或日期，分别小于或等于给定的数字或日期n。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.be.at.most(2); // Not recommended</span><br><span class="line">expect(1).to.be.at.most(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小小于或等于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.at.most(4); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.at.most(4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面加上.not来抵消.most</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.not.be.at.most(1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.most大多数情况下接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.be.at.most(1, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(2, &apos;nooo why fail??&apos;).to.be.at.most(1);</span><br></pre></td></tr></table></figure>
<p>别名.lte可以与.most互换使用</p>
<h2 id="within-start-finish-msg"><a href="#within-start-finish-msg" class="headerlink" title=".within(start, finish[, msg])"></a>.within(start, finish[, msg])</h2><ul>
<li>@param { Number } start lower bound inclusive</li>
<li>@param { Number } finish upper bound inclusive</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个数字或日期，大于或等于给定的数字或日期开始，小于或等于给定的数字或日期结束。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expect(2).to.equal(2); // Recommended</span><br><span class="line">expect(2).to.be.within(1, 3); // Not recommended</span><br><span class="line">expect(2).to.be.within(2, 3); // Not recommended</span><br><span class="line">expect(2).to.be.within(1, 2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.lengthOf，以断言目标的长度或大小大于或等于给定的数字start，小于或等于给定的数字finish</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf.within(2, 4); // Not recommended</span><br><span class="line"></span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.within(2, 4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.within</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.within(2, 4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.within接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(4).to.be.within(1, 3, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(4, &apos;nooo why fail??&apos;).to.be.within(1, 3);</span><br></pre></td></tr></table></figure>
<h2 id="instanceof-constructor-msg"><a href="#instanceof-constructor-msg" class="headerlink" title=".instanceof(constructor[, msg])"></a>.instanceof(constructor[, msg])</h2><ul>
<li>@param { Constructor } constructor</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是给定构造函数的实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Cat () &#123; &#125;</span><br><span class="line"></span><br><span class="line">expect(new Cat()).to.be.an.instanceof(Cat);</span><br><span class="line">expect([1, 2]).to.be.an.instanceof(Array);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.instanceof</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.be.an.instanceof(Array);</span><br></pre></td></tr></table></figure>
<p>.instanceof接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.an.instanceof(Array, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.an.instanceof(Array);</span><br></pre></td></tr></table></figure>
<p>由于ES5中的限制，.instanceof在使用Babel或TypeScript之类的换行器时可能并不总是像预期的那样工作。特别是，当子类化内置对象(如Array、Error和Map)时，可能会产生意想不到的结果</p>
<p>别名.instanceOf可以与.instanceOf互换使用</p>
<h2 id="property-name-val-msg"><a href="#property-name-val-msg" class="headerlink" title=".property(name[, val[, msg]])"></a>.property(name[, val[, msg]])</h2><ul>
<li>@param { String } name</li>
<li>@param { Mixed } val (optional)</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标具有具有给定键名的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<p>当提供val时，.property还断言属性的值等于给定的val</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;, 1);</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用strict(===)等式。在链的前面添加.deep来使用deep等式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Target object deeply (but not strictly) has property `x: &#123;a: 1&#125;`</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.have.deep.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.not.have.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br></pre></td></tr></table></figure>
<p>搜索中始终包含目标的可枚举和不可枚举属性。默认情况下，包括own和inherit属性。在链的前面添加.own，以从搜索中排除继承的属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.b = 2;</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1&#125;).to.have.own.property(&apos;a&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.own.property(&apos;a&apos;, 1);</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.not.have.own.property(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>.deep和.own可以组合在一起</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;x: &#123;a: 1&#125;&#125;).to.have.deep.own.property(&apos;x&apos;, &#123;a: 1&#125;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.nested，以便在引用嵌套属性时启用点符号和括号符号</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.have.nested.property(&apos;a.b[1]&apos;);</span><br><span class="line">expect(&#123;a: &#123;b: [&apos;x&apos;, &apos;y&apos;]&#125;&#125;).to.have.nested.property(&apos;a.b[1]&apos;, &apos;y&apos;);</span><br></pre></td></tr></table></figure>
<p>如果.或[]是实际属性名称的一部分，可以通过在它们前面添加两个反斜杠来转义它们</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&apos;.a&apos;: &#123;&apos;[b]&apos;: &apos;x&apos;&#125;&#125;).to.have.nested.property(&apos;\\.a.\\[b\\]&apos;);</span><br></pre></td></tr></table></figure>
<p>.deep和.nested 可以结合使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: &#123;b: [&#123;c: 3&#125;]&#125;&#125;)</span><br><span class="line">  .to.have.deep.nested.property(&apos;a.b[0]&apos;, &#123;c: 3&#125;);</span><br></pre></td></tr></table></figure>
<p>.own 与 .nested 不可以结合使用</p>
<p>使用 .not 否定 .property</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.have.property(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>然而,当提供val否定.property是很危险的。问题是,它创造了不确定性预期通过断言目标没有一个属性与给定的键名,或者它有一个属性与给定键的名字,但它的价值不等于给定的val。它通常是最好的选择来确定的预期的输出,然后写一个断言,只有承认准确输出</p>
<p>当预期目标不具有具有给定键名的属性时，通常最好准确地断言该属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;b: 2&#125;).to.not.have.property(&apos;a&apos;); // Recommended</span><br><span class="line">expect(&#123;b: 2&#125;).to.not.have.property(&apos;a&apos;, 1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当预期目标具有具有给定键名的属性时，通常最好断言该属性具有其期望值，而不是断言它没有许多未预料到的值之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 3&#125;).to.have.property(&apos;a&apos;, 3); // Recommended</span><br><span class="line">expect(&#123;a: 3&#125;).to.not.have.property(&apos;a&apos;, 1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>属性将链中随后的任何断言的目标更改为原始目标对象的属性值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;).that.is.a(&apos;number&apos;);</span><br></pre></td></tr></table></figure>
<p>属性接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供val时，只使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;a&apos;, 2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.property(&apos;a&apos;, 2);</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.property(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.property(&apos;b&apos;, undefined, &apos;nooo why fail??&apos;);</span><br></pre></td></tr></table></figure>
<p>上面的断言与不提供val不是一回事，相反，它断言目标对象有一个b属性，它等于undefined。<br>断言.ownProperty和. has ownproperty可以与.own.property互换使用</p>
<h2 id="ownPropertyDescriptor-name-descriptor-msg"><a href="#ownPropertyDescriptor-name-descriptor-msg" class="headerlink" title=".ownPropertyDescriptor(name[, descriptor[, msg]])"></a>.ownPropertyDescriptor(name[, descriptor[, msg]])</h2><ul>
<li>@param { String } name</li>
<li>@param { Object } descriptor <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标具有自己的具有给定键名的属性描述符。搜索中包括可枚举和不可枚举属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;);</span><br></pre></td></tr></table></figure>
<p>当提供描述符时，. ownpropertydescriptor还断言属性的描述符与给定的描述符深度相等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 1,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.ownPropertyDescriptor</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.have.ownPropertyDescriptor(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>但是，在提供描述符时否定. ownpropertydescriptor是很危险的。问题是，它通过断言目标没有具有给定键名的属性描述符，或者它确实具有具有给定键名的属性描述符，但它并不完全等于给定的描述符，从而产生了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言。<br>当目标不期望具有具有给定键名的属性描述符时，通常最好准确地断言该属性描述符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;b: 2&#125;).to.not.have.ownPropertyDescriptor(&apos;a&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;b: 2&#125;).to.not.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 1,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>当预期目标具有具有给定键名的属性描述符时，通常最好断言该属性具有其预期的描述符，而不是断言它没有许多未预料到的描述符之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 3&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 3,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;a: 3&#125;).to.not.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 1,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>ownpropertydescriptor将链中跟随的任何断言的目标更改为原始目标对象的属性描述符的值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;)</span><br><span class="line">  .that.has.property(&apos;enumerable&apos;, true);</span><br></pre></td></tr></table></figure>
<p>ownpropertydescriptor接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供描述符时，只使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 2,</span><br><span class="line">&#125;, &apos;nooo why fail??&apos;);</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.ownPropertyDescriptor(&apos;a&apos;, &#123;</span><br><span class="line">  configurable: true,</span><br><span class="line">  enumerable: true,</span><br><span class="line">  writable: true,</span><br><span class="line">  value: 2,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.ownPropertyDescriptor(&apos;b&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(&#123;a: 1&#125;)</span><br><span class="line">  .to.have.ownPropertyDescriptor(&apos;b&apos;, undefined, &apos;nooo why fail??&apos;);</span><br></pre></td></tr></table></figure>
<p>上面的断言与不提供描述符不是一回事。相反，它断言目标对象有一个深度等于undefined的b属性描述符。<br>别名.haveOwnPropertyDescriptor可以与.ownPropertyDescriptor互换使用</p>
<h2 id="lengthOf-n-msg"><a href="#lengthOf-n-msg" class="headerlink" title=".lengthOf(n[, msg])"></a>.lengthOf(n[, msg])</h2><ul>
<li>@param { Number } n</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标的长度或大小等于给定的数字n</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.have.lengthOf(3);</span><br><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3);</span><br><span class="line">expect(new Set([1, 2, 3])).to.have.lengthOf(3);</span><br><span class="line">expect(new Map([[&apos;a&apos;, 1], [&apos;b&apos;, 2], [&apos;c&apos;, 3]])).to.have.lengthOf(3);</span><br></pre></td></tr></table></figure>
<p>在链的前面加上 .not 否定 .lengthOf。然而，通常最好断言目标的length属性等于它的期望值，而不是不等于许多未预料到的值之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.have.lengthOf(3); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.have.lengthOf(4); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.lengthof接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.have.lengthOf(2, &apos;nooo why fail??&apos;);</span><br><span class="line">expect([1, 2, 3], &apos;nooo why fail??&apos;).to.have.lengthOf(2);</span><br></pre></td></tr></table></figure>
<p>lengthof也可以用作一个语言链，导致链中的所有.above、.below、.least、.most和.within断言都使用目标的length属性作为目标。但是，通常最好是断言目标的length属性等于它的预期长度，而不是断言它的length属性在某个值范围内</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf(3);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.above(2);</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.below(4);</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.at.least(3);</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.at.most(3);</span><br><span class="line">expect([1, 2, 3]).to.have.lengthOf.within(2,4);</span><br></pre></td></tr></table></figure>
<p>由于兼容性问题，别名.length不能直接链接到未调用的方法，如.a。因此，.length在任何情况下都不能和.length互换使用。建议总是使用.lengthOf而不是.length</p>
<h2 id="match-re-msg"><a href="#match-re-msg" class="headerlink" title=".match(re[, msg])"></a>.match(re[, msg])</h2><ul>
<li>@param { RegExp } re</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标匹配给定的正则表达式re</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.match(/^foo/);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.match</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.not.match(/taco/);</span><br></pre></td></tr></table></figure>
<p>.match接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.match(/taco/, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(&apos;foobar&apos;, &apos;nooo why fail??&apos;).to.match(/taco/);</span><br></pre></td></tr></table></figure>
<p>别名.matches可以与.match互换使用</p>
<h2 id="string-str-msg"><a href="#string-str-msg" class="headerlink" title=".string(str[, msg])"></a>.string(str[, msg])</h2><ul>
<li>@param { String } str</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标字符串包含给定的子字符串str</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.have.string(&apos;bar&apos;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.string</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.not.have.string(&apos;taco&apos;);</span><br></pre></td></tr></table></figure>
<p>.string接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foobar&apos;).to.have.string(&apos;taco&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(&apos;foobar&apos;, &apos;nooo why fail??&apos;).to.have.string(&apos;taco&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="keys-key1-key2-…"><a href="#keys-key1-key2-…" class="headerlink" title=".keys(key1[, key2[, …]])"></a>.keys(key1[, key2[, …]])</h2><ul>
<li>@param { String | Array | Object } keys</li>
</ul>
<p>断言目标对象、数组、映射或集合具有给定的键。搜索中只包含目标自身的继承属性。<br>当目标是对象或数组时，键可以作为一个或多个字符串参数、一个数组参数或一个对象参数提供。在后一种情况下，只有给定对象中的键起作用;这些值将被忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect([&apos;x&apos;, &apos;y&apos;]).to.have.all.keys(0, 1);</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.all.keys([&apos;a&apos;, &apos;b&apos;]);</span><br><span class="line">expect([&apos;x&apos;, &apos;y&apos;]).to.have.all.keys([0, 1]);</span><br><span class="line"></span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.all.keys(&#123;a: 4, b: 5&#125;); // ignore 4 and 5</span><br><span class="line">expect([&apos;x&apos;, &apos;y&apos;]).to.have.all.keys(&#123;0: 4, 1: 5&#125;); // ignore 4 and 5</span><br></pre></td></tr></table></figure>
<p>当目标是映射或设置时，必须将每个键作为单独的参数提供</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(new Map([[&apos;a&apos;, 1], [&apos;b&apos;, 2]])).to.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect(new Set([&apos;a&apos;, &apos;b&apos;])).to.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>因为.keys根据目标的类型执行不同的操作，所以在使用.keys之前检查目标的类型非常重要</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1, b: 2&#125;).to.be.an(&apos;object&apos;).that.has.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用strict(===)等式比较映射和集合的键。在链的前面添加.deep来使用deep等式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Target set deeply (but not strictly) has key `&#123;a: 1&#125;`</span><br><span class="line">expect(new Set([&#123;a: 1&#125;])).to.have.all.deep.keys([&#123;a: 1&#125;]);</span><br><span class="line">expect(new Set([&#123;a: 1&#125;])).to.not.have.all.keys([&#123;a: 1&#125;]);</span><br></pre></td></tr></table></figure>
<p>默认情况下，目标必须拥有所有给定的键，不能有更多。在链的前面添加.any，以只要求目标具有至少一个给定键。另外，在链的前面添加.not来否定.keys。通常，最好在否定.keys时添加.any，在断言.keys时使用.all而不进行否定。<br>在否定.keys时，首选.any，因为.not.any。keys断言输出的确切期望，而.not.all。钥匙会产生不确定的预期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Recommended; asserts that target doesn&apos;t have any of the given keys</span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.not.have.any.keys(&apos;c&apos;, &apos;d&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended; asserts that target doesn&apos;t have all of the given</span><br><span class="line">// keys but may or may not have some of them</span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.not.have.all.keys(&apos;c&apos;, &apos;d&apos;);</span><br></pre></td></tr></table></figure>
<p>在没有否定的情况下断言.keys时，.all是首选，因为.all.keys断言输出的确切内容，而.any。钥匙会产生不确定的预期<br>在否定.keys时，首选.any，因为.not.any.keys断言输出的确切期望，而.not.all。钥匙会产生不确定的预期</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Recommended; asserts that target has all the given keys</span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended; asserts that target has at least one of the given</span><br><span class="line">// keys but may or may not have more of them</span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.any.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>注意，当.all和.any都没有出现在链的前面时，默认情况下使用.all。不过，通常最好还是添加.all，因为它提高了可读性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Both assertions are identical</span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.all.keys(&apos;a&apos;, &apos;b&apos;); // Recommended</span><br><span class="line">expect(&#123;a: 1, b: 2&#125;).to.have.keys(&apos;a&apos;, &apos;b&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.include，要求目标的键是预期键的超集，而不是相同的键集</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Target object&apos;s keys are a superset of [&apos;a&apos;, &apos;b&apos;] but not identical</span><br><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.include.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1, b: 2, c: 3&#125;).to.not.have.all.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>但是，如果.any和.include组合在一起，则只有.any生效。在本例中，.include被忽略</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Both assertions are identical</span><br><span class="line">expect(&#123;a: 1&#125;).to.have.any.keys(&apos;a&apos;, &apos;b&apos;);</span><br><span class="line">expect(&#123;a: 1&#125;).to.include.any.keys(&apos;a&apos;, &apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.have.key(&apos;b&apos;);</span><br></pre></td></tr></table></figure>
<p>别名.key可以与.keys互换使用</p>
<h2 id="throw-errorLike-errMsgMatcher-msg"><a href="#throw-errorLike-errMsgMatcher-msg" class="headerlink" title=".throw([errorLike], [errMsgMatcher], [msg])"></a>.throw([errorLike], [errMsgMatcher], [msg])</h2><ul>
<li>@param { Error | ErrorConstructor } errorLike</li>
<li>@param { String | RegExp } errMsgMatcher error message</li>
<li>@param { String } msg <em>optional</em></li>
<li>@see <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types" target="_blank" rel="noopener">https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Error#Error_types</a></li>
</ul>
<p>当没有提供参数时，.throw调用目标函数并断言抛出了错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var badFn = function () &#123; throw new TypeError(&apos;Illegal salmon!&apos;); &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw();</span><br></pre></td></tr></table></figure>
<p>当提供了一个参数，它是一个错误构造函数时，.throw调用目标函数并断言抛出了一个错误，该错误是该错误构造函数的一个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var badFn = function () &#123; throw new TypeError(&apos;Illegal salmon!&apos;); &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw(TypeError);</span><br></pre></td></tr></table></figure>
<p>当提供了一个参数，它是一个错误构造函数时，.throw调用目标函数并断言抛出了一个错误，该错误是这个错误构造函数的一个实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var err = new TypeError(&apos;Illegal salmon!&apos;);</span><br><span class="line">var badFn = function () &#123; throw err; &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw(err);</span><br></pre></td></tr></table></figure>
<p>当提供了一个参数(它是一个字符串)时，.throw调用目标函数并断言抛出了一个包含该字符串的消息的错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var badFn = function () &#123; throw new TypeError(&apos;Illegal salmon!&apos;); &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw(&apos;salmon&apos;);</span><br></pre></td></tr></table></figure>
<p>当提供了一个参数(它是一个正则表达式)时，.throw调用目标函数并断言抛出了一个错误，该错误带有一条匹配该正则表达式的消息</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var badFn = function () &#123; throw new TypeError(&apos;Illegal salmon!&apos;); &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw(/salmon/);</span><br></pre></td></tr></table></figure>
<p>当提供两个参数时，第一个参数是一个错误实例或构造函数，第二个参数是一个字符串或正则表达式，.throw调用该函数并断言抛出的错误满足了上述两种条件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var err = new TypeError(&apos;Illegal salmon!&apos;);</span><br><span class="line">var badFn = function () &#123; throw err; &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw(TypeError, &apos;salmon&apos;);</span><br><span class="line">expect(badFn).to.throw(TypeError, /salmon/);</span><br><span class="line">expect(badFn).to.throw(err, &apos;salmon&apos;);</span><br><span class="line">expect(badFn).to.throw(err, /salmon/);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.throw</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var goodFn = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(goodFn).to.not.throw();</span><br></pre></td></tr></table></figure>
<p>然而，在提供任何参数时否定.throw是危险的。问题是,它创造了不确定性预期通过断言目标不会抛出错误,或者它将抛出一个错误但比给定的类型,不同类型的给定类型的或它将抛出一个错误,但不包括给定字符串的消息。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言。<br>当预期目标不会抛出错误时，最好准确地断言错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var goodFn = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(goodFn).to.not.throw(); // Recommended</span><br><span class="line">expect(goodFn).to.not.throw(ReferenceError, &apos;x&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当目标预计将抛出一个错误,最好经常声称其预期类型的错误,和有一个消息,包括预期的字符串,而不是声称它没有许多意想不到的类型之一,和没有消息,包括一些stringoutput。<br>当预期目标不会抛出错误时，最好准确地断言错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var badFn = function () &#123; throw new TypeError(&apos;Illegal salmon!&apos;); &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw(TypeError, &apos;salmon&apos;); // Recommended</span><br><span class="line">expect(badFn).to.not.throw(ReferenceError, &apos;x&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.throw将链中随后的任何断言的目标更改为抛出的错误对象<br>当预期目标不会抛出错误时，最好准确地断言错误</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var err = new TypeError(&apos;Illegal salmon!&apos;);</span><br><span class="line">err.code = 42;</span><br><span class="line">var badFn = function () &#123; throw err; &#125;;</span><br><span class="line"></span><br><span class="line">expect(badFn).to.throw(TypeError).with.property(&apos;code&apos;, 42);</span><br></pre></td></tr></table></figure>
<p>.throw接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供两个参数时，始终使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var goodFn = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(goodFn).to.throw(TypeError, &apos;x&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(goodFn, &apos;nooo why fail??&apos;).to.throw();</span><br></pre></td></tr></table></figure>
<p>由于ES5中的限制，.throw在使用Babel或TypeScript等转换程序时，可能并不总是像预期的那样工作。特别是，当子类化内置错误对象，然后将子类化的构造函数传递给.throw时，可能会产生意想不到的结果<br>使用抛出断言时要注意一些常见的错误。一个常见的错误是意外地自己调用函数，而不是让抛出断言为您调用函数。例如，当测试一个名为fn的函数是否抛出时，提供fn而不是fn()作为断言的目标</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(fn).to.throw();     // Good! Tests `fn` as desired</span><br><span class="line">expect(fn()).to.throw();   // Bad! Tests result of `fn()`, not `fn`</span><br></pre></td></tr></table></figure>
<p>如果需要断言函数fn在传递某些参数时抛出，则在另一个函数中封装对fn的调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(function () &#123; fn(42); &#125;).to.throw();  // Function expression</span><br><span class="line">expect(() =&gt; fn(42)).to.throw();             // ES6 arrow function</span><br></pre></td></tr></table></figure>
<p>另一个常见错误是将对象方法(或依赖于此方法的任何独立函数)作为断言的目标。这样做是有问题的，因为当.throw调用函数时，这个上下文将会丢失;它不可能知道这是什么。有两种方法可以解决这个问题。一种解决方案是将方法或函数调用封装在另一个函数中。另一个解决方案是使用bind</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(function () &#123; cat.meow(); &#125;).to.throw();  // Function expression</span><br><span class="line">expect(() =&gt; cat.meow()).to.throw();             // ES6 arrow function</span><br><span class="line">expect(cat.meow.bind(cat)).to.throw();           // Bind</span><br></pre></td></tr></table></figure>
<p>最后，值得一提的是，JavaScript中的最佳实践是只抛出错误和派生错误，如ReferenceError、TypeError和扩展错误的用户定义对象。初始化时，没有其他类型的值会生成堆栈跟踪。尽管如此，抛出断言在技术上支持抛出任何类型的值，而不仅仅是错误及其派生。<br>别名.Throw和.Throw可以与.Throw互换使用</p>
<h2 id="respondTo-method-msg"><a href="#respondTo-method-msg" class="headerlink" title=".respondTo(method[, msg])"></a>.respondTo(method[, msg])</h2><ul>
<li>@param { String } method</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>当目标是非函数对象时，.respondto断言目标具有具有给定名称方法的方法。方法可以是自己的或继承的，也可以是可枚举的或不可枚举的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Cat () &#123;&#125;</span><br><span class="line">Cat.prototype.meow = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(new Cat()).to.respondTo(&apos;meow&apos;);</span><br></pre></td></tr></table></figure>
<p>当目标是一个函数时，.respondto断言目标的prototype属性有一个具有给定name方法的方法。同样，方法可以是自己的或继承的，也可以是可枚举的或不可枚举的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Cat () &#123;&#125;</span><br><span class="line">Cat.prototype.meow = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(Cat).to.respondTo(&apos;meow&apos;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.self来强制.respondto将目标视为一个非函数对象，即使它是一个函数。因此，它断言目标具有具有给定名称方法的方法，而不是断言目标的prototype属性具有具有给定名称方法的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Cat () &#123;&#125;</span><br><span class="line">Cat.prototype.meow = function () &#123;&#125;;</span><br><span class="line">Cat.hiss = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(Cat).itself.to.respondTo(&apos;hiss&apos;).but.not.respondTo(&apos;meow&apos;);</span><br></pre></td></tr></table></figure>
<p>当不添加.self时，在使用.respondto之前检查目标的类型是很重要的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Cat () &#123;&#125;</span><br><span class="line">Cat.prototype.meow = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(new Cat()).to.be.an(&apos;object&apos;).that.respondsTo(&apos;meow&apos;);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来否定.respondTo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Dog () &#123;&#125;</span><br><span class="line">Dog.prototype.bark = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(new Dog()).to.not.respondTo(&apos;meow&apos;);</span><br></pre></td></tr></table></figure>
<p>.respondto接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;&#125;).to.respondTo(&apos;meow&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(&#123;&#125;, &apos;nooo why fail??&apos;).to.respondTo(&apos;meow&apos;);</span><br></pre></td></tr></table></figure>
<p>别名.respondsTo可以与.respondTo互换使用</p>
<h2 id="itself"><a href="#itself" class="headerlink" title=".itself"></a>.itself</h2><p>强制链中跟随的所有.respondto断言表现得好像目标是一个非函数对象，即使它是一个函数。因此，它导致.respondTo断言目标具有具有给定名称的方法，而不是断言目标的prototype属性具有具有给定名称的方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Cat () &#123;&#125;</span><br><span class="line">Cat.prototype.meow = function () &#123;&#125;;</span><br><span class="line">Cat.hiss = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(Cat).itself.to.respondTo(&apos;hiss&apos;).but.not.respondTo(&apos;meow&apos;);</span><br></pre></td></tr></table></figure>
<h2 id="satisfy-matcher-msg"><a href="#satisfy-matcher-msg" class="headerlink" title=".satisfy(matcher[, msg])"></a>.satisfy(matcher[, msg])</h2><ul>
<li>@param { Function } matcher</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>调用给定的matcher函数，将目标作为第一个参数传递，并断言返回的值是真实的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.satisfy(function(num) &#123;</span><br><span class="line">  return num &gt; 0;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>在.satisfy前添加.not否定.satisfy</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.not.satisfy(function(num) &#123;</span><br><span class="line">  return num &gt; 2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>.satisfy接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.satisfy(function(num) &#123;</span><br><span class="line">  return num &gt; 2;</span><br><span class="line">&#125;, &apos;nooo why fail??&apos;);</span><br><span class="line"></span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.satisfy(function(num) &#123;</span><br><span class="line">  return num &gt; 2;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>别名.satisfy可以与.satisfy互换使用</p>
<h2 id="closeTo-expected-delta-msg"><a href="#closeTo-expected-delta-msg" class="headerlink" title=".closeTo(expected, delta[, msg])"></a>.closeTo(expected, delta[, msg])</h2><ul>
<li>@param { Number } expected</li>
<li>@param { Number } delta</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是一个给定值的正负范围内的数字。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// Recommended</span><br><span class="line">expect(1.5).to.equal(1.5);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(1.5).to.be.closeTo(1, 0.5);</span><br><span class="line">expect(1.5).to.be.closeTo(2, 0.5);</span><br><span class="line">expect(1.5).to.be.closeTo(1, 1);</span><br></pre></td></tr></table></figure>
<p>在.closeTo前添加.not否定.closeTo</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1.5).to.equal(1.5); // Recommended</span><br><span class="line">expect(1.5).to.not.be.closeTo(3, 1); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.close to接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1.5).to.be.closeTo(3, 1, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1.5, &apos;nooo why fail??&apos;).to.be.closeTo(3, 1);</span><br></pre></td></tr></table></figure>
<p>别名.nearly可以与.close互换使用</p>
<h2 id="members-set-msg"><a href="#members-set-msg" class="headerlink" title=".members(set[, msg])"></a>.members(set[, msg])</h2><ul>
<li>@param { Array } set</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标数组具有与给定数组集相同的成员</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.have.members([2, 1, 3]);</span><br><span class="line">expect([1, 2, 2]).to.have.members([2, 1, 2]);</span><br></pre></td></tr></table></figure>
<p>默认情况下，使用strict(===)等式比较成员。在链的前面添加.deep来使用deep等式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// Target array deeply (but not strictly) has member `&#123;a: 1&#125;`</span><br><span class="line">expect([&#123;a: 1&#125;]).to.have.deep.members([&#123;a: 1&#125;]);</span><br><span class="line">expect([&#123;a: 1&#125;]).to.not.have.members([&#123;a: 1&#125;]);</span><br></pre></td></tr></table></figure>
<p>默认情况下，顺序并不重要。在链的前面添加.ordered，以要求成员以相同的顺序出现</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2, 3]).to.have.ordered.members([1, 2, 3]);</span><br><span class="line">expect([1, 2, 3]).to.have.members([2, 1, 3])</span><br><span class="line">  .but.not.ordered.members([2, 1, 3]);</span><br></pre></td></tr></table></figure>
<p>默认情况下，两个数组的大小必须相同。在链的前面添加.include，以要求目标成员是预期成员的超集。注意，当添加.include时，在子集中会忽略重复项</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// Target array is a superset of [1, 2] but not identical</span><br><span class="line">expect([1, 2, 3]).to.include.members([1, 2]);</span><br><span class="line">expect([1, 2, 3]).to.not.have.members([1, 2]);</span><br><span class="line"></span><br><span class="line">// Duplicates in the subset are ignored</span><br><span class="line">expect([1, 2, 3]).to.include.members([1, 2, 2, 2]);</span><br></pre></td></tr></table></figure>
<p>.deep、.ordered和.include都可以组合。但是，如果.include和.ordered组合在一起，则从两个数组的开头开始排序</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">expect([&#123;a: 1&#125;, &#123;b: 2&#125;, &#123;c: 3&#125;])</span><br><span class="line">  .to.include.deep.ordered.members([&#123;a: 1&#125;, &#123;b: 2&#125;])</span><br><span class="line">  .but.not.include.deep.ordered.members([&#123;b: 2&#125;, &#123;c: 3&#125;]);</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not以否定.members。然而，这样做是危险的。问题是，它断言目标数组不具有与给定数组集合相同的所有成员，但可能有也可能没有其中一些成员，从而产生了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2]).to.not.include(3).and.not.include(4); // Recommended</span><br><span class="line">expect([1, 2]).to.not.have.members([3, 4]); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.members接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect([1, 2]).to.have.members([1, 2, 3], &apos;nooo why fail??&apos;);</span><br><span class="line">expect([1, 2], &apos;nooo why fail??&apos;).to.have.members([1, 2, 3]);</span><br></pre></td></tr></table></figure>
<h2 id="oneOf-list-msg"><a href="#oneOf-list-msg" class="headerlink" title=".oneOf(list[, msg])"></a>.oneOf(list[, msg])</h2><ul>
<li>@param { Array.&lt;*&gt; } list</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>断言目标是给定数组列表的成员。然而，通常最好断言目标等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.be.oneOf([1, 2, 3]); // Not recommended</span><br></pre></td></tr></table></figure>
<p>比较使用严格的等式(===)执行</p>
<p>在.oneOf前添加.not否定.oneOf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.equal(1); // Recommended</span><br><span class="line">expect(1).to.not.be.oneOf([2, 3, 4]); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.one接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.oneOf([2, 3, 4], &apos;nooo why fail??&apos;);</span><br><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.oneOf([2, 3, 4]);</span><br></pre></td></tr></table></figure>
<h2 id="change-subject-prop-msg"><a href="#change-subject-prop-msg" class="headerlink" title=".change(subject[, prop[, msg]])"></a>.change(subject[, prop[, msg]])</h2><ul>
<li>@param { String } subject</li>
<li>@param { String } prop name <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>当提供一个参数时，.change断言给定的函数subject在调用目标函数之前返回的值与在调用目标函数之后返回的值不同。然而，通常最好是断言subject等于它的期望值</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var dots = &apos;&apos;</span><br><span class="line">  , addDot = function () &#123; dots += &apos;.&apos;; &#125;</span><br><span class="line">  , getDots = function () &#123; return dots; &#125;;</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">expect(getDots()).to.equal(&apos;&apos;);</span><br><span class="line">addDot();</span><br><span class="line">expect(getDots()).to.equal(&apos;.&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(addDot).to.change(getDots);</span><br></pre></td></tr></table></figure>
<p>当提供两个参数时，.change断言给定对象主体的prop属性的值在调用目标函数之前与调用之后是不同的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;dots: &apos;&apos;&#125;</span><br><span class="line">  , addDot = function () &#123; myObj.dots += &apos;.&apos;; &#125;;</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">expect(myObj).to.have.property(&apos;dots&apos;, &apos;&apos;);</span><br><span class="line">addDot();</span><br><span class="line">expect(myObj).to.have.property(&apos;dots&apos;, &apos;.&apos;);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(addDot).to.change(myObj, &apos;dots&apos;);</span><br></pre></td></tr></table></figure>
<p>Strict(===)等式用于比较前后值</p>
<p>在.change前添加.not否定.change</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var dots = &apos;&apos;</span><br><span class="line">  , noop = function () &#123;&#125;</span><br><span class="line">  , getDots = function () &#123; return dots; &#125;;</span><br><span class="line"></span><br><span class="line">expect(noop).to.not.change(getDots);</span><br><span class="line"></span><br><span class="line">var myObj = &#123;dots: &apos;&apos;&#125;</span><br><span class="line">  , noop = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(noop).to.not.change(myObj, &apos;dots&apos;);</span><br></pre></td></tr></table></figure>
<p>.change接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供两个参数时，始终使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;dots: &apos;&apos;&#125;</span><br><span class="line">  , addDot = function () &#123; myObj.dots += &apos;.&apos;; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addDot).to.not.change(myObj, &apos;dots&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line"></span><br><span class="line">var dots = &apos;&apos;</span><br><span class="line">  , addDot = function () &#123; dots += &apos;.&apos;; &#125;</span><br><span class="line">  , getDots = function () &#123; return dots; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addDot, &apos;nooo why fail??&apos;).to.not.change(getDots);</span><br></pre></td></tr></table></figure>
<p>.change还通过链中的所有.by断言断言一个数字主题增加或减少了多少。但是，使用.change.by是很危险的。问题是，它通过断言主体要么增加给定的增量，要么减少给定的增量，从而产生不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , addTwo = function () &#123; myObj.val += 2; &#125;</span><br><span class="line">  , subtractTwo = function () &#123; myObj.val -= 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(addTwo).to.change(myObj, &apos;val&apos;).by(2); // Not recommended</span><br><span class="line"></span><br><span class="line">expect(subtractTwo).to.decrease(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(subtractTwo).to.change(myObj, &apos;val&apos;).by(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>别名.changes可以与.change互换使用</p>
<h2 id="increase-subject-prop-msg"><a href="#increase-subject-prop-msg" class="headerlink" title=".increase(subject[, prop[, msg]])"></a>.increase(subject[, prop[, msg]])</h2><ul>
<li>@param { String | Function } subject</li>
<li>@param { String } prop name <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>提供一个参数时,.increase断言给定的函数对象返回更多的时候调用在调用目标函数相对于事先的时候调用。.increase也导致链中的基本观点断言遵循断言返回的数字是大多少。通常，最好是断言返回值增加了预期的数量，而不是断言它增加了任何数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var val = 1</span><br><span class="line">  , addTwo = function () &#123; val += 2; &#125;</span><br><span class="line">  , getVal = function () &#123; return val; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addTwo).to.increase(getVal).by(2); // Recommended</span><br><span class="line">expect(addTwo).to.increase(getVal); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当提供两个参数时，.increase断言在调用目标函数后，给定对象主体的prop属性的值要比调用前大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , addTwo = function () &#123; myObj.val += 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面添加.not来抵消.increase。然而，这样做是危险的。问题在于，它通过断言主题要么减少，要么保持不变，从而产生了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言。<br>当预期主题减少时，通常最好断言它减少了预期的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , subtractTwo = function () &#123; myObj.val -= 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(subtractTwo).to.decrease(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(subtractTwo).to.not.increase(myObj, &apos;val&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当主题被期望保持不变时，最好准确地断言这一点<br>当预期主题减少时，通常最好断言它减少了预期的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , noop = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(noop).to.not.change(myObj, &apos;val&apos;); // Recommended</span><br><span class="line">expect(noop).to.not.increase(myObj, &apos;val&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>.increase接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供两个参数时，始终使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , noop = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(noop).to.increase(myObj, &apos;val&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line"></span><br><span class="line">var val = 1</span><br><span class="line">  , noop = function () &#123;&#125;</span><br><span class="line">  , getVal = function () &#123; return val; &#125;;</span><br><span class="line"></span><br><span class="line">expect(noop, &apos;nooo why fail??&apos;).to.increase(getVal);</span><br></pre></td></tr></table></figure>
<p>别名.increase可以与.increase互换使用</p>
<h2 id="decrease-subject-prop-msg"><a href="#decrease-subject-prop-msg" class="headerlink" title=".decrease(subject[, prop[, msg]])"></a>.decrease(subject[, prop[, msg]])</h2><ul>
<li>@param { String | Function } subject</li>
<li>@param { String } prop name <em>optional</em></li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>提供一个参数时,.decrease断言给定的函数对象返回一个较小的数量的时候调用在调用目标函数相对于事先的时候调用。.decrease也导致链中的基本观点断言遵循坚持返回小数量的多少。通常，最好是断言返回值减少了预期的数量，而不是断言它减少了任何数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var val = 1</span><br><span class="line">  , subtractTwo = function () &#123; val -= 2; &#125;</span><br><span class="line">  , getVal = function () &#123; return val; &#125;;</span><br><span class="line"></span><br><span class="line">expect(subtractTwo).to.decrease(getVal).by(2); // Recommended</span><br><span class="line">expect(subtractTwo).to.decrease(getVal); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当提供两个参数时，. reduce断言在调用目标函数之后，给定对象主体的prop属性的值比调用之前的值要小</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , subtractTwo = function () &#123; myObj.val -= 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(subtractTwo).to.decrease(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(subtractTwo).to.decrease(myObj, &apos;val&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>在链的前面加上.not否定.reduce。然而，这样做是危险的。问题在于，它通过断言主题要么增加，要么保持不变，从而产生了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言。<br>当预期主题会增加时，通常最好断言它增加了预期的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , addTwo = function () &#123; myObj.val += 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(addTwo).to.not.decrease(myObj, &apos;val&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>当主题被期望保持不变时，最好准确地断言这一点<br>当预期主题会增加时，通常最好断言它增加了预期的数量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , noop = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(noop).to.not.change(myObj, &apos;val&apos;); // Recommended</span><br><span class="line">expect(noop).to.not.decrease(myObj, &apos;val&apos;); // Not recommended</span><br></pre></td></tr></table></figure>
<p>reduce接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出。当不提供两个参数时，始终使用第二种形式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , noop = function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">expect(noop).to.decrease(myObj, &apos;val&apos;, &apos;nooo why fail??&apos;);</span><br><span class="line"></span><br><span class="line">var val = 1</span><br><span class="line">  , noop = function () &#123;&#125;</span><br><span class="line">  , getVal = function () &#123; return val; &#125;;</span><br><span class="line"></span><br><span class="line">expect(noop, &apos;nooo why fail??&apos;).to.decrease(getVal);</span><br></pre></td></tr></table></figure>
<p>别名.reduction可以与.reduction互换使用</p>
<h2 id="by-delta-msg"><a href="#by-delta-msg" class="headerlink" title=".by(delta[, msg])"></a>.by(delta[, msg])</h2><ul>
<li>@param { Number } delta</li>
<li>@param { String } msg <em>optional</em></li>
</ul>
<p>当在链中跟随.increase断言时，.by断言.increase断言的主题增加了给定的增量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , addTwo = function () &#123; myObj.val += 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).by(2);</span><br></pre></td></tr></table></figure>
<p>当在链中跟随.reduce断言时，.by断言.reduce断言的主语减少了给定的增量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , subtractTwo = function () &#123; myObj.val -= 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(subtractTwo).to.decrease(myObj, &apos;val&apos;).by(2);</span><br></pre></td></tr></table></figure>
<p>当在链中跟随.change断言时，.by断言.change断言的主题增加或减少了给定的增量。但是，使用.change.by是很危险的。问题在于，它带来了不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , addTwo = function () &#123; myObj.val += 2; &#125;</span><br><span class="line">  , subtractTwo = function () &#123; myObj.val -= 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(addTwo).to.change(myObj, &apos;val&apos;).by(2); // Not recommended</span><br><span class="line"></span><br><span class="line">expect(subtractTwo).to.decrease(myObj, &apos;val&apos;).by(2); // Recommended</span><br><span class="line">expect(subtractTwo).to.change(myObj, &apos;val&apos;).by(2); // Not recommended</span><br></pre></td></tr></table></figure>
<p>添加.not在.by前否定.by。然而，通常最好是断言主题根据预期的增量进行了更改，而不是断言它没有通过无数个意外增量中的一个进行更改</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , addTwo = function () &#123; myObj.val += 2; &#125;;</span><br><span class="line"></span><br><span class="line">// Recommended</span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).by(2);</span><br><span class="line"></span><br><span class="line">// Not recommended</span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).but.not.by(3);</span><br></pre></td></tr></table></figure>
<p>.by接受一个可选的msg参数，该参数是一个自定义错误消息，用于在断言失败时显示。消息也可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var myObj = &#123;val: 1&#125;</span><br><span class="line">  , addTwo = function () &#123; myObj.val += 2; &#125;;</span><br><span class="line"></span><br><span class="line">expect(addTwo).to.increase(myObj, &apos;val&apos;).by(3, &apos;nooo why fail??&apos;);</span><br><span class="line">expect(addTwo, &apos;nooo why fail??&apos;).to.increase(myObj, &apos;val&apos;).by(3);</span><br></pre></td></tr></table></figure>
<h2 id="extensible"><a href="#extensible" class="headerlink" title=".extensible"></a>.extensible</h2><p>断言目标是可扩展的，这意味着可以向其添加新属性。原语是不可扩展的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.be.extensible;</span><br></pre></td></tr></table></figure>
<p>添加.not在.extensible前否定.extensible</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var nonExtensibleObject = Object.preventExtensions(&#123;&#125;)</span><br><span class="line">  , sealedObject = Object.seal(&#123;&#125;)</span><br><span class="line">  , frozenObject = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">expect(nonExtensibleObject).to.not.be.extensible;</span><br><span class="line">expect(sealedObject).to.not.be.extensible;</span><br><span class="line">expect(frozenObject).to.not.be.extensible;</span><br><span class="line">expect(1).to.not.be.extensible;</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(1, &apos;nooo why fail??&apos;).to.be.extensible;</span><br><span class="line">.sealed</span><br></pre></td></tr></table></figure>
<h2 id="sealed"><a href="#sealed" class="headerlink" title=".sealed"></a>.sealed</h2><p>断言目标是密封的，这意味着不能向其添加新属性，也不能重新配置或删除其现有属性。但是，它现有的属性仍然可以重新分配到不同的值。原语总是密封的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var sealedObject = Object.seal(&#123;&#125;);</span><br><span class="line">var frozenObject = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">expect(sealedObject).to.be.sealed;</span><br><span class="line">expect(frozenObject).to.be.sealed;</span><br><span class="line">expect(1).to.be.sealed;</span><br></pre></td></tr></table></figure>
<p>添加.not在.sealed前否定.sealed</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.be.sealed;</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.be.sealed;</span><br></pre></td></tr></table></figure>
<h2 id="frozen"><a href="#frozen" class="headerlink" title=".frozen"></a>.frozen</h2><p>断言目标被冻结，这意味着不能向其添加新属性，并且不能将其现有属性重新分配到不同的值、重新配置或删除。原语总是被冻结的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var frozenObject = Object.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line">expect(frozenObject).to.be.frozen;</span><br><span class="line">expect(1).to.be.frozen;</span><br></pre></td></tr></table></figure>
<p>添加.not在.frozen前否定.frozen</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;).to.not.be.frozen;</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&#123;a: 1&#125;, &apos;nooo why fail??&apos;).to.be.frozen;</span><br></pre></td></tr></table></figure>
<h2 id="finite"><a href="#finite" class="headerlink" title=".finite"></a>.finite</h2><p>断言目标是一个数字，而不是NaN或正/负无穷大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(1).to.be.finite;</span><br></pre></td></tr></table></figure>
<p>在链的前面加上。而不是减去。limited。然而，这样做是危险的。问题是，它通过断言主语不是一个数字，或者是NaN，或者是正无穷，或者是负无穷，来产生不确定的预期。通常，最好确定预期的确切输出，然后编写只接受该确切输出的断言。<br>当预期目标不是一个数字时，通常最好断言它是预期的类型，而不是断言它不是许多意外类型之一</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;).to.be.a(&apos;string&apos;); // Recommended</span><br><span class="line">expect(&apos;foo&apos;).to.not.be.finite; // Not recommended</span><br></pre></td></tr></table></figure>
<p>当预期目标是NaN时，通常最好准确地断言这一点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(NaN).to.be.NaN; // Recommended</span><br><span class="line">expect(NaN).to.not.be.finite; // Not recommended</span><br></pre></td></tr></table></figure>
<p>当目标被期望为正无穷时，最好准确地断言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(Infinity).to.equal(Infinity); // Recommended</span><br><span class="line">expect(Infinity).to.not.be.finite; // Not recommended</span><br></pre></td></tr></table></figure>
<p>当目标被期望为负无穷时，最好准确地断言</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect(-Infinity).to.equal(-Infinity); // Recommended</span><br><span class="line">expect(-Infinity).to.not.be.finite; // Not recommended</span><br></pre></td></tr></table></figure>
<p>自定义错误消息可以作为第二个参数给出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect(&apos;foo&apos;, &apos;nooo why fail??&apos;).to.be.finite;</span><br></pre></td></tr></table></figure>
<h2 id="fail-message"><a href="#fail-message" class="headerlink" title=".fail([message])"></a>.fail([message])</h2><h2 id="fail-actual-expected-message-operator"><a href="#fail-actual-expected-message-operator" class="headerlink" title=".fail(actual, expected, [message], [operator])"></a>.fail(actual, expected, [message], [operator])</h2><ul>
<li>@param { Mixed } actual</li>
<li>@param { Mixed } expected</li>
<li>@param { String } message</li>
<li>@param { String } operator</li>
</ul>
<p>抛出一个失败</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">expect.fail();</span><br><span class="line">expect.fail(&quot;custom error message&quot;);</span><br><span class="line">expect.fail(1, 2);</span><br><span class="line">expect.fail(1, 2, &quot;custom error message&quot;);</span><br><span class="line">expect.fail(1, 2, &quot;custom error message&quot;, &quot;&gt;&quot;);</span><br><span class="line">expect.fail(1, 2, undefined, &quot;&gt;&quot;);</span><br></pre></td></tr></table></figure>
  </article>
  <aside class="table-content" id="site-toc">
  <div class="table-content-title">
    <i class="fa fa-arrow-right fa-lg" id="site-toc-hide-btn"></i>
    <span>目录</span>
  </div>
  <div class="table-content-main">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#BDD"><span class="toc-text">BDD</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#语言链"><span class="toc-text">语言链</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#not"><span class="toc-text">.not</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#deep"><span class="toc-text">.deep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nested"><span class="toc-text">.nested</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#own"><span class="toc-text">.own</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ordered"><span class="toc-text">.ordered</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#any"><span class="toc-text">.any</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#all"><span class="toc-text">.all</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#a-type-msg"><span class="toc-text">.a(type[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#include-val-msg"><span class="toc-text">.include(val[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ok"><span class="toc-text">.ok</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#true"><span class="toc-text">.true</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#false"><span class="toc-text">.false</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#null"><span class="toc-text">.null</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#undefined"><span class="toc-text">.undefined</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#NaN"><span class="toc-text">.NaN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#exist"><span class="toc-text">.exist</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#empty"><span class="toc-text">.empty</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arguments"><span class="toc-text">.arguments</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#equal-val-msg"><span class="toc-text">.equal(val[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#eql-obj-msg"><span class="toc-text">.eql(obj[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#above-n-msg"><span class="toc-text">.above(n[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#least-n-msg"><span class="toc-text">.least(n[,msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#below-n-msg"><span class="toc-text">.below(n[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#most-n-msg"><span class="toc-text">.most(n[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#within-start-finish-msg"><span class="toc-text">.within(start, finish[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#instanceof-constructor-msg"><span class="toc-text">.instanceof(constructor[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#property-name-val-msg"><span class="toc-text">.property(name[, val[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ownPropertyDescriptor-name-descriptor-msg"><span class="toc-text">.ownPropertyDescriptor(name[, descriptor[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#lengthOf-n-msg"><span class="toc-text">.lengthOf(n[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#match-re-msg"><span class="toc-text">.match(re[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-str-msg"><span class="toc-text">.string(str[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#keys-key1-key2-…"><span class="toc-text">.keys(key1[, key2[, …]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#throw-errorLike-errMsgMatcher-msg"><span class="toc-text">.throw([errorLike], [errMsgMatcher], [msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#respondTo-method-msg"><span class="toc-text">.respondTo(method[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#itself"><span class="toc-text">.itself</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#satisfy-matcher-msg"><span class="toc-text">.satisfy(matcher[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#closeTo-expected-delta-msg"><span class="toc-text">.closeTo(expected, delta[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#members-set-msg"><span class="toc-text">.members(set[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#oneOf-list-msg"><span class="toc-text">.oneOf(list[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#change-subject-prop-msg"><span class="toc-text">.change(subject[, prop[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#increase-subject-prop-msg"><span class="toc-text">.increase(subject[, prop[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#decrease-subject-prop-msg"><span class="toc-text">.decrease(subject[, prop[, msg]])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#by-delta-msg"><span class="toc-text">.by(delta[, msg])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#extensible"><span class="toc-text">.extensible</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sealed"><span class="toc-text">.sealed</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#frozen"><span class="toc-text">.frozen</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#finite"><span class="toc-text">.finite</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fail-message"><span class="toc-text">.fail([message])</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#fail-actual-expected-message-operator"><span class="toc-text">.fail(actual, expected, [message], [operator])</span></a></li></ol></li></ol>
  </div>
</aside>
  
  
    <div class="passage-tags">
     
      <a href="/tags/js/"><i class="fa fa-tags"></i>js</a>
     
      <a href="/tags/单元测试/"><i class="fa fa-tags"></i>单元测试</a>
    
    </div>
  
</div>

    </main>
    
      
<div class="site-comment-contanier" data-plateform="leancloud">
  
    <p id="site-comment-info">
      <i class="fa fa-spinner fa-spin"></i> 评论加载中
    </p>
    <div id="site-comment"></div>
  
</div>
    
    <div class="site-footer-wrapper">
  <footer class="site-footer">
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">博客推荐</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/" target="_blank">GodBMW</a>
          </span>
        
          <span class="site-footer-item">
            <a href="http://ruanyifeng.com/" target="_blank">阮一峰的个人网站</a>
          </span>
        
      </div>
    
      <div class="site-footer-col">
        <h5 class="site-footer-title">系列教程</h5>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/categories/webpack4%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B/" target="_blank">webpack4系列教程</a>
          </span>
        
          <span class="site-footer-item">
            <a href="https://godbmw.com/design-patterns/" target="_blank">设计模式手册</a>
          </span>
        
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-clock-o"></i> 本站已稳定运行<span id="site-time"></span>
    </div>
    
      <div class="site-footer-info">
        <i class="fa fa-paw"></i> 您是本站第 <span id="site-count"></span> 位访客
      </div>
    
    
      <div class="site-footer-info">
        <i class="fa fa-at"></i> Email: ysulixiangyuan@gmail.com
      </div>
    
    <div class="site-footer-info">
      <i class="fa fa-copyright"></i> 
      2019 <a href="https://github.com/dongyuanxin/theme-ad/" target="_blank">Theme-AD</a>.
      Created by <a href="https://godbmw.com/" target="_blank">GodBMW</a>.
      All rights reserved.
    </div>
  </footer>
</div>
    <div id="site-layer" style="display:none;">
  <div class="site-layer-content">
    <div class="site-layer-header">
      <span class="site-layer-header-title" id="site-layer-title"></span>
      <i class="fa fa-close" id="site-layer-close"></i>
    </div>
    <div class="site-layer-body" id="site-layer-container">
      <div class="site-layer-input" id="site-layer-search" style="display: none;">
        <input type="text">
        <i class="fa fa-search"></i>
      </div>
      <div class="site-layer-reward" id="site-layer-reward" style="display: none;">
        
          <div>
            <img src="/images/wechat.png" alt="WeChat">
            
              <p>WeChat</p>
            
          </div>
        
          <div>
            <img src="/images/alipay.png" alt="AliPay">
            
              <p>AliPay</p>
            
          </div>
        
      </div>
      <div id="site-layer-welcome" style="display:none;"></div>
    </div>
  </div>
</div>
    

<div class="bottom-bar">
  <div class="bottom-bar-left">
    <a href="/passages/Literary-sentence/" data-enable="true">
      <i class="fa fa-arrow-left"></i>
    </a>
    <a href="/passages/CSS选择器以及CSS三大特性/" data-enable="true">
      <i class="fa fa-arrow-right"></i>
    </a>
  </div>
  <div class="bottom-bar-right">
    <a href="javascript:void(0);" data-enable="true" id="site-toc-show-btn">
      <i class="fa fa-bars"></i>
    </a>
    
      <a href="#site-comment" data-enable="true">
        <i class="fa fa-commenting"></i>
      </a>
    
    <a href="javascript:void(0);" id="site-toggle-share-btn">
      <i class="fa fa-share-alt"></i>
    </a>
    <a href="javascript:void(0);" id="site-reward">
      <i class="fa fa-thumbs-up"></i>
    </a>
    <a href="javascript:void(0);" id="back-top-btn">
      <i class="fa fa-chevron-up"></i>
    </a>
  </div>
</div>
    <div id="share-btn">
  
    <a id="share-btn-twitter" href="javascript:void(0);" target="_blank">
      <i class="fa fa-twitter"></i>
    </a>
  
  
    <a id="share-btn-facebook" href="javascript:void(0);" target="_blank">
      <i class="fa fa-facebook"></i>
    </a>
  
  
    <a id="share-btn-weibo" href="javascript:void(0);" target="_blank">
      <i class="fa fa-weibo"></i>
    </a>
  
  
    <a id="share-btn-qq" href="javascript:void(0);" target="_blank">
      <i class="fa fa-qq"></i>
    </a>
  
  
    <a id="share-btn-wechat" href="javascript:void(0);" target="_blank">
      <i class="fa fa-wechat"></i>
    </a>
  
</div>
    





    
  </body>
</html>